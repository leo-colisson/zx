\documentclass[a4paper,doc2]{ltxdoc} % doc2 is needed to force the old version, or links get colored in a weird red way even with hidelinks. https://github.com/latex3/latex2e/issues/822

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Packages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Warning: if you compile and get:
%% ERROR: Argument of \tikz@lib@matrix@with@options has an extra }.
%% make sure to fix catcodes around it as | is given a different meaning in ltxdoc.

\usepackage{amsmath}
\usepackage[margin=3cm]{geometry}
\usepackage{calc}
\usepackage{tikz}
\usetikzlibrary{shadows,fit}
% \usetikzlibrary fails because file is not in current directory, lazy to setup TEXINPUTS
\makeatletter
  \input{../tikzlibraryzx-calculus.code.tex}
\makeatother
% Loads the great package that produces tikz-like manual (see also tikzcd for examples)
\input{pgfmanual-en-macros.tex} % Is supposed to be included in recent TeX distributions, but I get errors...
\usepackage{makeidx} % Produces an index of commands.
\makeindex % Useful or not index will be created
\usepackage{alertmessage} % For warning, info...
\usepackage[hidelinks]{hyperref}
\newcommand{\mylink}[2]{\href{#1}{#2}\footnote{\url{#1}}}
\usepackage{verbatim}
\usepackage{cleveref}
\usepackage{mathtools}
\usepackage{listings}

%%%% Bibliography
% I want to have separate references for appendix and main body
% https://tex.stackexchange.com/questions/98660/
\usepackage[style=trad-alpha,
  sortcites=true,
  doi=false,
  url=false,
  giveninits=true, % Bob Foo --> B. Foo
  isbn=false,
  url=false,
  eprint=false,
  sortcites=false, % \cite{B,A,C}: [A,B,C] --> [B,A,C]
]{biblatex}
\renewcommand{\multicitedelim}{, } % [ABC96; DEF12] -> [ABC96, DEF12]
% [unknown_ref] => [??]
% https://tex.stackexchange.com/a/352573
\makeatletter
\protected\def\abx@missing#1{\textbf{??}}
\makeatother
\renewcommand*{\bibfont}{\normalfont\small} % BibLatex font seems bigger than Bibtex?
\addbibresource{biblio.bib}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Documentation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
%%% Title: thanks tikzcd for the styling
\begin{center}
  \vspace*{1em} % Thanks tikzcd
  \tikz\node[scale=1.2]{%
    \color{gray}\Huge\ttfamily \char`\{\raisebox{.09em}{\textcolor{red!75!black}{zx\raisebox{-0.1em}{-}calculus}}\char`\}};

  \vspace{0.5em}
  {\Large\bfseries ZX-calculus with \tikzname}

  \vspace{1em}
  {LÃ©o Colisson \quad Version 2023/04/24}\\[3mm]
  {\href{https://github.com/leo-colisson/zx-calculus}{\texttt{github.com/leo-colisson/zx-calculus}}}
\end{center}

\tableofcontents

\section{Introduction}

This library (based on the great \tikzname{} and \tikzname-cd packages) allows you to typeset ZX-calculus and diagrams for diagrammatic reasoning~\cite{CK17_PicturingQuantumProcesses,van20_ZXcalculusWorkingQuantum} directly in \LaTeX{}. It comes with a default---but highly customizable---style:
\begin{codeexample}[]
  \begin{ZX}
    \zxZ{\alpha} \arrow[r] & \zxFracX-{\pi}{4}
  \end{ZX}
\end{codeexample}
Even if this has not yet been tested a lot, you can also use a ``phase in label'' style, without really changing the code:
\begin{codeexample}[]
  \begin{ZX}[phase in label right]
    \zxZ{\alpha} \arrow[d] \\
    \zxFracX-{\pi}{4}
  \end{ZX}
\end{codeexample}

Since 24/02/2023, we also provide ways to easily create new, highly customizable shapes, with text, anchors, sub-nodes, rotations, and more:
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
% Define a reusable node
\zxNewNodeFromPic{MyDivider}[][zx create anchors={\zxVirtualCenterWest, \zxVirtualCenterEast},
  every node/.append style={transform shape}
  ]{
  \node[regular polygon, regular polygon sides=3,shape border rotate=90,%shape border rotate=90,
        draw=black,fill=gray!50, inner sep=1.6pt, rounded corners=0.8mm,zx main node] {};
  \coordinate(\zxVirtualCenterEast) at (.2mm,0); % Used to start lines on the side of the shape
  \coordinate(\zxVirtualCenterWest) at (-1mm,0);
}
% Use the node
\begin{ZX}
                            & [2mm]                           & [3mm] \zxN{} \\[\zxZeroRow]
 \zxZ[B]{} \rar[Bn'=n+m, wc] & \zxMyDivider{}
                              \rar[<',ru,Bn'Args={n}{pos=.7}]
                              \rar[Bn.Args={m}{pos=.7},<.,rd] &\\[\zxZeroRow]
                            &                                 & \zxN{}
\end{ZX}
\end{codeexample}
}


The goal is to provide an alternative to the great |tikzit| package: we wanted a solution that does not require the creation of an additional file, the use of an external software, and which automatically adapts the width of columns and rows depending on the content of the nodes (in |tikzit| one needs to manually tune the position of each node, especially when dealing with large nodes). Our library also provides a default style and tries to separate the content from the style: that way it should be easy to globally change the styling of a given project without redesigning all diagrams. However, it should be fairly easy to combine tikzit and this library: when some diagrams are easier to design in tikzit, then it should be possible to directly load the style of this library inside tikzit.

This library is quite young, so feel free to propose improvements or report issues on \href{https://github.com/leo-colisson/zx-calculus/issues}{\texttt{github.com/leo-colisson/zx-calculus/issues}}. We will of course try to maintain backward compatibility as much as possible, but we can't guarantee at 100\% that small changes (spacing, wire looks\dots{}) won't be made later. In case you want a completely unalterable style, just copy the two files of this library in your project forever (see installation)!

\section{Installation}

If your CTAN distribution is recent enough, you can directly insert in your file:
% verse indents stuff, index adds to the index of command at the end of the file, || is a shortcut of \verb||
\begin{verse}
  \index{zx@\protect\texttt{zx-calculus} package}%
  \index{Packages and files!zx-calculus@\protect\texttt{zx-calculus}}%
  |\usepackage{zx-calculus}|%
\end{verse}
or load \tikzname{} and then use:
\begin{verse}%
   \index{cd@\protect\texttt{zx-calculus} library}%
   \index{Libraries!cd@\protect\texttt{zx-calculus}}%
   |\usetikzlibrary{zx-calculus}|%
\end{verse}
If this library is not yet packaged into CTAN (which is very likely in 2021), you must first download \mylink{https://github.com/leo-colisson/zx-calculus/blob/main/tikzlibraryzx-calculus.code.tex}{\texttt{tikzlibraryzx-calculus.code.tex}} and \mylink{https://github.com/leo-colisson/zx-calculus/blob/main/zx-calculus.sty}{\texttt{zx-calculus.sty}} (right-click on ``Raw'' and ``Save link as'') and save them at the root of your project.

\section{Quickstart}

You can create a diagram either with |\zx[options]{matrix}|, |\zxAmp[options]{matrix}| or with:
\begin{verse}
  |\begin{ZX}[options]|\\
    |  matrix|\\
  |\end{ZX}|
\end{verse}
The matrix is composed of rows separated by |\\| and columns separated by |&| (except in |\zxAmp| where columns are separated with |\&|).

% \alertwarning{ % Can't use |...| or \verb|...| in this environment :'(
%   Due to \LaTeX{} restrictions, \texttt{\&} can sometimes cause some troubles. \texttt{\textbackslash{}zxAmp} is always guaranteed to work (just make sure to use \texttt{\textbackslash{}\&} instead of \texttt{\&}). See \cref{subsec:addDiagram} for more details.
% }

This matrix is basically a \tikzname{} matrix of nodes (even better, a |tikz-cd| matrix, so you can use all the machinary of |tikz-cd|), so cells can be created using \verb#|[tikz style]| content#. However, the users does not usually need to use this syntax since many nodes like |\zxZ{spider phase}| have been created for them (including |\zxN{}| which is an empty node):

\begin{codeexample}[width=0pt]
\begin{ZX}
  \zxZ{} & \zxZ{\alpha} & \zxZ-{\alpha} & \zxZ{\alpha+\beta} & \zxFracZ{\pi}{2} & \zxFracZ-{\pi}{2}\\
  \zxX{} & \zxX{\alpha} & \zxX-{\alpha} & \zxX{\alpha+\beta} & \zxFracX{\pi}{2} & \zxFracX-{\pi}{2}\\
  \zxN{} & \zxH{}
\end{ZX}
\end{codeexample}

Note that if a node has no argument like |\zxN|, you should still end it like |\zxN{}| to make sure you code will be backward compatible and will behave correctly.

To link the nodes, you should use |\arrow[options]| (|\ar[options]| for short) at the end of a cell (you can put many arrows). The options can contain a direction, made of a string of |r| (for ``right''), |l| (for ``left''), |d| (for `down''), |u| (for ``up'') letters. That way, |\ar[rrd]| would be an arrow going right, right, and down:
\begin{codeexample}[]
\begin{ZX}
  \zxZ{} \ar[rrd] & \zxX{}\\
                  &        & \zxX-{\alpha}
\end{ZX}
\end{codeexample}
See how the alignment of your matrix helps reading it: in emacs |M-x align| is your friend (or even better, if you are tired of selecting the lines to align, bind \mylink{https://tex.stackexchange.com/a/64566/116348}{this \texttt{align-environment} function} to some shortcuts, like |C-<tab>| and you will just have to do a single key-press to align your matrix).

You may also encounter some shortcuts, like |\rar| instead of |\ar[r]|. Since straight lines are boring, we created many styles that you can just add in the options. For instance, a measured Bell-pair can be created using the |C| style (note also how the |*| argument forces the node to be tighter):
\begin{codeexample}[]
\begin{ZX}
  \zxZ*{a \pi} \ar[d,C]\\
  \zxZ*{b \pi}
\end{ZX}
\end{codeexample}
The name of the style usually tries to graphically represent the shape of a node (here it looks like a |C|). We also introduce many other styles, like |N| for wires that arrive and leave at wide angle (yeah, the |N| is the best letter I could find to fit that shape):
\begin{codeexample}[]
\begin{ZX}
  \zxN{}                           & \zxZ{\beta}\\
  \zxZ{\alpha} \ar[ru,N] \ar[rd,N] &\\
                                   & \zxZ{\gamma}
\end{ZX}
\end{codeexample}
Or |s| for wires that arrive and leave at sharp angles\footnote{Note: on older versions, a |\zxN{}| might be needed on the first cell as it seems that the first cell of a matrix can't be emptyâ¦ this should be fixed in latest versions.}:
\begin{codeexample}[]
\begin{ZX}
                                   & \zxZ{\beta} \\
  \zxZ{\alpha} \ar[ru,s] \ar[rd,s] &             \\
                                   & \zxZ{\gamma}
\end{ZX}
\end{codeexample}
You have then different variations of a style depending on the shape and/or direction of it. For instance, if we want the arrival of the |N| wire to be flat, use |N-|:
\begin{codeexample}[]
\begin{ZX}
  \zxZ{\alpha} \ar[rd,N-] \\
                         & \zxZ{\beta}
\end{ZX}
\end{codeexample}
Similarly |o'| is a style for wires that have the shape of the top part of the circle, and comes with variations depending on the part of the circle that must be kept:
\begin{codeexample}[width=0pt]
\begin{ZX}
  \zxZ{\alpha} \ar[r,o',green] \ar[r,o.,red] \ar[d,o-,blue] \ar[d,-o,purple] & \zxZ{\beta}\\
  \zxZ{\beta}
\end{ZX}
\end{codeexample}
Note that the position of the embellishments (|'|, |-|, |.|\dots{}) tries to graphically represent the shape of the node. That way |-o| means ``take the left part (position of |-|) of the circle |o|''. Applied to |C|, this gives:
\begin{codeexample}[]
\begin{ZX}
  \zxX{} \ar[d,C] \ar[r,C']  & \zxZ{} \ar[d,C-]\\
  \zxZ{} \ar[r,C.]           & \zxX{}
\end{ZX}
\end{codeexample}

You also have styles which automatically add another node in between, for instance |H| adds a Hadamard node in the middle of the node:
\begin{codeexample}[]
\begin{ZX}
  \zxZ{\alpha} \ar[r,o',H] \ar[r,o.,H] &[\zxHCol] \zxZ{\beta}
\end{ZX}
\end{codeexample}
Note that we used also |&[\zxHCol]| instead of |&| (on the first line). This is useful to add an extra space between the columns to have a nicer look. The same apply for rows (see the |*Row| instead of |*Col|):
\begin{codeexample}[]
\begin{ZX}
  \zxZ{\alpha} \ar[d,-o,Z] \ar[d,o-,X] \\[\zxSRow]
  \zxX{\beta}
\end{ZX}
\end{codeexample}
The reason for this is that it is hard to always get exactly the good spacing by default (for instance here \tikzname{} has no idea that a |H| node will be inserted when it starts to build the diagram), and sometimes the spacing needs some adjustments. However, while you could manually tweak this space using something like |&[1mm]| (it adds |1mm| to the column space), it is better to use some pre-configured spaced that can be (re)-configured document-wise to keep a uniform spacing. You could define your own spacing, but we already provide a list for the most important spacings. They all start with |zx|, then you find the type of space: |H| for Hadamard, |S| for spiders, |W| when you connect only |\zxNone| nodes (otherwise the diagram will be too shrinked), |w| when one side of the row contains only |\zxNone|\dots{} and then you find |Col| (for columns spacing) or |Row| (for rows spacing). For instance we can use the |\zxNone| style (|\zxN| for short) style and the above spacing to obtain this:
\begin{codeexample}[]
\begin{ZX}
  \zxN{} \rar &[\zxwCol] \zxH{} \rar &[\zxwCol] \zxN{}
\end{ZX}
\end{codeexample}
\noindent or that:
\begin{codeexample}[]
\begin{ZX}
  \zxN{} \ar[d,C] \ar[dr,s] &[\zxWCol] \zxN{} \\[\zxWRow]
  \zxN{} \ar[ru,s]          &          \zxN{} \\
\end{ZX}
\end{codeexample}


When writing equations, you may also want to change the baseline to align properly your diagrams on a given line like that (since march 2023):
\begin{codeexample}[]
  $\zx[mbr=2]{ % mbr is a shortcut for "math baseline row"
    \zxX{}\\
    \zxZ[a=myZ]{}
  }
  = \zx{\zxX{} & \zxZ{}}$
\end{codeexample}
You can also specify (this works on older versions) a specific node like that (|a=blabla| gives the alias name |blabla| to the node, and configure tools useful for debugging):
\begin{codeexample}[]
  $\zx[math baseline=myZ]{
    \zxX{}\\
    \zxZ[a=myZ]{}
  }
  = \zx{\zxX{} & \zxZ{}}$
\end{codeexample}

We also provide easy methods like |phase in label right| to change the labelling of a note (per-node, per-picture or document wise) to move the phase in a label automatically:
\begin{codeexample}[]
  \begin{ZX}[phase in label right]
    \zxZ{\alpha} \arrow[d] \\
    \zxFracX-{\pi}{4}
  \end{ZX}
\end{codeexample}

Now you should know enough to start your first diagrams. The rest of the documentation will go through all the styles, customizations and features, including the one needed to obtain:
\begin{codeexample}[width=3cm]
\begin{ZX}
  \leftManyDots{n} \zxX{\alpha} \zxLoopAboveDots{} \middleManyDots{} \ar[r,o'={a=75}]
      & \zxX{\beta} \zxLoopAboveDots{} \rightManyDots{m}
\end{ZX}
\end{codeexample}
\noindent You will also see some tricks (notably based on alias) to create clear bigger diagrams, like this debug mode which turns
{
\begin{ZX}[zx row sep=1pt,
  execute at begin picture={%
    %%% Definition of long items (the goal is to have a small and readable matrix
    % (warning: macro can't have numbers in TeX. Also, make sure not to use existing names)
    \def\Zpifour{\zxFracZ[a=Zpi4]-{\pi}{4}}%
    \def\mypitwo{\zxFracX[a=mypi2]{\pi}{2}}%
  }
  ]
  %%% Matrix: in emacs "M-x align" is practical to automatically format it. a is for 'alias'
  & \zxN[a=n]{}  & \zxZ[a=xmiddle]{}       &            & \zxN[a=out1]{} \\
  \zxN[a=in1]{} & \Zpifour{}   & \zxX[a=Xdown]{}         & \mypitwo{} &                \\
  &              &                         &            & \zxN[a=out2]{} \\
  \zxN[a=in2]{} & \zxX[a=X1]{} & \zxZ[a=toprightpi]{\pi} &            & \zxN[a=out3]{}
  %%% Arrows
  % Column 1
  \ar[from=in1,to=X1,s]
  \ar[from=in2,to=Zpi4,.>]
  % Column 2
  \ar[from=X1,to=xmiddle,N']
  \ar[from=X1,to=toprightpi,H]
  \ar[from=Zpi4,to=n,C] \ar[from=n,to=xmiddle,wc]
  \ar[from=Zpi4,to=Xdown]
  % Column 3
  \ar[from=xmiddle,to=Xdown,C-]
  \ar[from=xmiddle,to=mypi2,)]
  % Column 4
  \ar[from=mypi2,to=toprightpi,(']
  \ar[from=mypi2,to=out1,<']
  \ar[from=mypi2,to=out2,<.]
  \ar[from=Xdown,to=out3,<.]
\end{ZX} into %
{%
  \def\zxDebugMode{}%%%%
  \begin{ZX}[zx row sep=1pt,
    execute at begin picture={%
      %%% Definition of long items (the goal is to have a small and readable matrix
      % (warning: macro can't have numbers in TeX. Also, make sure not to use existing names)
      \def\Zpifour{\zxFracZ[a=Zpi4]-{\pi}{4}}%
      \def\mypitwo{\zxFracX[a=mypi2]{\pi}{2}}%
    }
    ]
    %%% Matrix: in emacs "M-x align" is practical to automatically format it. a is for 'alias'
    & \zxN[a=n]{}  & \zxZ[a=xmiddle]{}       &            & \zxN[a=out1]{} \\
    \zxN[a=in1]{} & \Zpifour{}   & \zxX[a=Xdown]{}         & \mypitwo{} &                \\
    &              &                         &            & \zxN[a=out2]{} \\
    \zxN[a=in2]{} & \zxX[a=X1]{} & \zxZ[a=toprightpi]{\pi} &            & \zxN[a=out3]{}
    %%% Arrows
    % Column 1
    \ar[from=in1,to=X1,s]
    \ar[from=in2,to=Zpi4,.>]
    % Column 2
    \ar[from=X1,to=xmiddle,N']
    \ar[from=X1,to=toprightpi,H]
    \ar[from=Zpi4,to=n,C] \ar[from=n,to=xmiddle,wc]
    \ar[from=Zpi4,to=Xdown]
    % Column 3
    \ar[from=xmiddle,to=Xdown,C-]
    \ar[from=xmiddle,to=mypi2,)]
    % Column 4
    \ar[from=mypi2,to=toprightpi,(']
    \ar[from=mypi2,to=out1,<']
    \ar[from=mypi2,to=out2,<.]
    \ar[from=Xdown,to=out3,<.]
  \end{ZX}
} \ (of course it only helps during the construction).\\

You will also see how you can customize the styles, and how you can easily extend this library to get any custom diagram:
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
{ % \usetikzlibrary{shadows}
  \tikzset{
    my bloc/.style={
      anchor=center,
      inner sep=2pt,
      inner xsep=.7em,
      minimum height=3em,
      draw,
      thick,
      fill=blue!10!white,
      double copy shadow={opacity=.5},tape,
    }
  }
  \zx{|[my bloc]| f \rar &[1mm] |[my bloc]| g \rar &[1mm] \zxZ{\alpha} \rar & \zxNone{}}
}
\end{codeexample}
}

If you have some questions, suggestions, or bugs, please report them on \texttt{\url{https://github.com/leo-colisson/zx-calculus/issues}}.

\textbf{Tips}: if you are unsure of the definition of a style in an example, just click on it, a link will point to its definition. Also, if your pdf viewer does not copy/paste these examples correctly, you can copy them from the source code of this documentation available \mylink{https://github.com/leo-colisson/zx-calculus/blob/main/doc/zx-calculus.tex}{here} (to find the example, just use the ``search'' function of your web browser).

\section{Usage}

\subsection{Add a diagram}\label{subsec:addDiagram}
\begin{pgfmanualentry}
  \extractcommand\zx\opt{\oarg{options}}\marg{your diagram}\@@
  \extractenvironement{ZX}\opt{\oarg{options}}\@@
  \extractcommand\zxAmp\opt{\oarg{options}}\marg{your diagram}\@@
  \pgfmanualbody
  You can create a new ZX-diagram either with a macro (quicker for inline diagrams) or with an environment. All these commands are mostly equivalent, except that in |\zxAmp| columns are separated with |\&| instead of |&| (this was useful before as |&| was not usable in |align| or inside macros. Now it should be fixed.). The \meta{options} can be used to locally change the style of the diagram, using the same options as the |{tikz-cd}| environment (from the \mylink{https://www.ctan.org/pkg/tikz-cd}{\texttt{tikz-cd} package}). The \meta{your diagram} argument, or the content of |{ZX}| environment is a \tikzname{} matrix of nodes, exactly like in the |tikz-cd| package: rows are separated using |\\|, columns using |&| (except for |\zxAmp| where columns are separated using |\&|), and nodes are created using \verb#|[tikz style]| node content# or with shortcut commands presented later in this document (recommended). Wires can be added like in |tikz-cd| (see more below) using |\arrow| or |\ar|: we provide later recommended styles to quickly create different kinds of wires which can change with the configured style. Content is typeset in math mode by default, and diagrams can be included in any equation.
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
% Do not indent not to put space in final code
\begin{codeexample}[]
Spider \zx{\zxZ{\alpha}}, equation $\zx{\zxZ{}} = \zx{\zxX{}}$ %
and custom diagram: %
\begin{ZX}[red]
  \zxZ{\beta} \arrow[r]                           & \zxZ{\alpha} \\
  |[fill=pink,draw]| \gamma \arrow[ru,bend right]
\end{ZX}
\end{codeexample}
}
\end{pgfmanualentry}

\begin{stylekey}{/zx/defaultEnv/amp}
  In a previous version (before 2022/02/09), it was not possible to use |&| inside macros and |align| due to \LaTeX{} limitations. However, we found a solution by re-scanning the tokens, so now no special care should be taken in align or macros. But in case you need to deal with an environment having troubles with |&|, either use the |ampersand replacement=\&| option (whose shortcut is |amp|) or |\zxAmp| (in any case, replace |&| with |\&|).
\begin{codeexample}[vbox]
An aligned equation:
\begin{align}
  \zxAmp{\zxZ{} \arrow[r] \& \zxX{}} &= \begin{ZX}[amp] \zxX{} \arrow[r] \& \zxZ{} \end{ZX}
\end{align}
This limitation does not apply anymore:
\begin{align}
  \zx{\zxZ{} \arrow[r] & \zxX{}} &= \begin{ZX} \zxX{} \arrow[r] & \zxZ{} \end{ZX}
\end{align}
even in macros: {\setlength{\fboxsep}{0pt} \fbox{\zx{\zxZ{} \rar & \zxX{}}}}
\end{codeexample}
\end{stylekey}

\subsection{Nodes}
\subsubsection{Spiders}
The following commands are useful to create different kinds of nodes. Always add empty arguments like |\example{}| if none are already present, otherwise if you type |\example| we don't guarantee backward compatibility.

\begin{command}{\zxEmptyDiagram{}}
  Create an empty diagram.
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxEmptyDiagram{}
\end{ZX}
\end{codeexample}
\end{command}


\begin{pgfmanualentry}
  \extractcommand\zxNone\opt{-\textbar+}\marg{text}\@@
  \extractcommand\zxN\opt{-\textbar+}\marg{text}\@@
  \extractcommand\zxNL\@@
  \extractcommand\zxNR\@@
  \pgfmanualbody
  Adds an empty node with |\zxNone{}| (alias |\zxN{}|). The \verb#-|+# decorations are used to add a bit of horizontal (\verb#\zxNone-{}#), vertical (\verb#\zxNone|{}#) and both (\verb#\zxNone+{}#) spacing.

  |\zxNone| is just a coordinate (and therefore can't have any text inside, but when possible this node should be preferred over the other versions since it has really zero width), but |\zxNone-{}| and \verb#\zxNone|{}# are actually nodes with |inner sep=0| along one direction. For that reason, they still have a tiny height or width (impossible to remove as far as I know). If you don't want to get holes when connecting multiple wires to them, it is therefore necessary to use |\zxNone{}| or the |wire centered| style (alias |wc|) (if you are using the |IO| mode, see also the |between none| style). But anyway you should mostly use |\zxNone|.

  Moreover, you should also add column and row spacing |&[\zxWCol]| and |\\[\zxWRow]| to avoid too shrinked diagrams when only wires are involved.
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxNone{} \ar[C,d] \ar[rd,s] &[\zxWCol] \zxNone{}\\[\zxWRow]
  \zxNone{}          \ar[ru,s] &          \zxNone{}
\end{ZX}
\end{codeexample}
Use |&[\zxwCol]| (on the first line) and/or |\\[\zxwRow]| when a single None node is connected to the wire to add appropriate spacing (this spacing can of course be redefined to your preferences):
\begin{codeexample}[]
Compare \begin{ZX}
  \zxN{} \rar & \zxZ{} \rar & \zxN{}
\end{ZX} with \begin{ZX}
  \zxN{} \rar &[\zxwCol] \zxZ{} \rar &[\zxwCol] \zxN{}
\end{ZX}
\end{codeexample}
This kind of code is so common that there is an alias for it: |\zxNL| and |\zxNR| automatically add a |\zxN{}| node, configure the column space (for this reason don't add an additional |&|, and be aware that emacs won't align them properly. Note also that the space will only be taken into account if it is on the first line) and add a straight arrow. The |L/R| part of the name is just to specify if the node is on the right or left of the diagram to put the column and arrow on the right side:
\begin{codeexample}[]
\zx{\zxNL \zxX{} \zxNR}
\end{codeexample}
Note that these two alias can be used without |{}|. But they are the only ones.

The \verb!\zxN|{text}! and \verb!\zxN-{text}! may be useful to display some texts:
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[]
  \begin{ZX}[content fixed baseline]
    & \zxN|{\dots} \dar                                                                 \\
    \zxZ{\theta_i} \rar & \zxZ{} \dar \rar & \zxZ{-(\delta_i+\theta_i+r\pi)}\rar & \zxH{} \rar & \zxX{a\pi} \\
    & \zxN|{\dots}                                                                      \\
  \end{ZX}
\end{codeexample}
}

When the top left cell is empty, you may get an error at the compilation |Single ampersand used with wrong catcode| (this error should be fixed in latest releases) or |<symbol> allowed only in math mode| (not sure why). To solve this issue, you can add an empty node on the very first cell:
\begin{codeexample}[]
\begin{ZX}
  \zxN{}         &[\zxwCol] \zxN{} \ar[d]\\[\zxwRow]
  \zxNone{} \rar & \zxZ{}
\end{ZX}
\end{codeexample}
\end{pgfmanualentry}

You may also get the error |Single ampersand used with wrong catcode| when |&| has already a different meaning, for instance in |align|, in that case you may change the |&| character into |\&| using |[ampersand replacement=\&]|. Note however that in recent versions ($\geq$ 2022/02/09) this should not happen anymore.
\begin{codeexample}[vbox]
\begin{align}
  \begin{ZX}[ampersand replacement=\&]
    \zxN{} \rar \&[\zxWCol] \zxN{}
  \end{ZX}
  &= \begin{ZX}[ampersand replacement=\&]
    \zxN{} \rar \&[\zxwCol] \zxZ{} \rar \&[\zxwCol] \zxN{}
  \end{ZX}\\
  &= \begin{ZX}[ampersand replacement=\&]
    \zxN{} \rar \&[\zxwCol] \zxX{} \rar \&[\zxwCol] \zxN{}
  \end{ZX}
\end{align}
\end{codeexample}

\begin{command}{\zxNoneDouble\opt{-\textbar+}\marg{text}}
  Like |\zxNone|, but the spacing for \verb#-|+# is large enough to fake two lines in only one. Not extremely useful (or one needs to play with |start anchor=south,end anchor=north|).
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxNoneDouble|{} \ar[r,s,start anchor=north,end anchor=south] \ar[r,s,start anchor=south,end anchor=north] &[\zxWCol] \zxNoneDouble|{}
\end{ZX}
\end{codeexample}
}
\end{command}

\begin{command}{\zxFracZ\opt{-}\marg{numerator}\opt{\oarg{numerator with parens}\oarg{denominator with parens}}\marg{denominator}}
  Adds a Z node with a fraction, use the minus decorator to add a small minus in front (a normal minus would be too big, but you can configure the symbol).
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxFracZ{\pi}{2} & \zxFracZ-{\pi}{2}
\end{ZX}
\end{codeexample}
The optional arguments are useful when the numerator or the denominator need parens when they are written inline (in that case optional arguments must be specified): it will prove useful when using a style that writes the fraction inline, for instance the default style for labels:
\begin{codeexample}[]
Compare %
\begin{ZX}
  \zxFracZ{a+b}[(a+b)][(c+d)]{c+d}
\end{ZX} with %
\begin{ZX}[phase in label right]
  \zxFracZ{a+b}[(a+b)][(c+d)]{c+d}
\end{ZX}
\end{codeexample}
\end{command}

\begin{command}{\zxFracX\opt{-}\marg{numerator}\marg{denominator}}
  Adds an X node with a fraction.
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxFracX{\pi}{2} & \zxFracX-{\pi}{2}
\end{ZX}
\end{codeexample}
\end{command}

\begin{command}{\zxZ\opt{\oarg{other styles}*-}\marg{text}}
  Adds a Z node. \meta{other styles} are optional \tikzname{} arguments (the same as the one provided to |tikz-cd|) They should be use with care, and if possible moved to the style directly to keep a consistent look across the paper.
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxZ{} & \zxZ{\alpha} & \zxZ{\alpha + \beta} & \zxZ[fill=blue!50!white,text=red]{(a \oplus b)\pi}
\end{ZX}
\end{codeexample}
The optional |-| optional argument is to add a minus sign (customizable, see |\zxMinusInShort|) in front of a very short expression and try to keep a circular shape. This is recommended notably for single letter expressions.
\begin{codeexample}[width=3cm]
  Compare \zx{\zxZ{-\alpha}} with \zx{\zxZ-{\alpha}}. Labels:
  \zx[pila]{\zxZ{-\alpha}} vs \zx[pila]{\zxZ-{\alpha}}.
\end{codeexample}
The |*| optional argument is to force a condensed style, no matter what is the text inside. This can be practical \emph{sometimes}:
\begin{codeexample}[width=3cm]
  Compare \zx{\zxN{} \rar &[\zxwCol] \zxZ{a\pi}} with \zx{\zxN{} \rar &[\zxwCol] \zxZ*{a\pi}}.
\end{codeexample}
\noindent but you should use it as rarely as possible (otherwise, change the style directly). See that it does not always give nice results:
\begin{codeexample}[width=3cm]
  Compare \zx{\zxZ{-\alpha} \rar & \zxZ{\alpha+\beta}}
  with \zx{\zxZ*{-\alpha} \rar & \zxZ*{\alpha+\beta}}.
  Labels:
  \zx[pila]{\zxZ{-\alpha} \rar & \zxZ{\alpha+\beta}}
  vs \zx[pila]{\zxZ*{-\alpha} \rar & \zxZ*{\alpha+\beta}}.
\end{codeexample}
\end{command}


\begin{command}{\zxX\opt{\oarg{other styles}*-}\marg{text}}
  Adds an X node, like for the Z node.
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxX{} & \zxX{\alpha} & \zxX-{\alpha} & \zxX{\alpha + \beta}
  & \zxX[text=green]{(a \oplus b)\pi}
\end{ZX}
\end{codeexample}
\end{command}

\begin{command}{\zxH\opt{\oarg{other styles}}}
  Adds an Hadamard node. See also |H| wire style.
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxNone{} \rar & \zxH{} \rar & \zxNone{}
\end{ZX}
\end{codeexample}
\end{command}



\begin{command}{\leftManyDots\opt{\oarg{text scale}\oarg{dots scale}}\marg{text}}
  Shortcut to add a dots and a text next to it. It automatically adds the new column, see more examples below. Internally, it uses |3 dots| to place the dots, and can be reproduced using the other nodes around. Note that this node automatically adds a new cell, so you should \emph{not} use |&|.
\begin{codeexample}[]
\begin{ZX}
  \leftManyDots{n} \zxX{\alpha}
\end{ZX}
\end{codeexample}
\end{command}

\begin{command}{\leftManyDots\opt{\oarg{text scale}\oarg{dots scale}}\marg{text}}
  Shortcut to add a dots and a text next to it. It automatically adds the new column, see more examples below.
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxX{\alpha} \rightManyDots{m}
\end{ZX}
\end{codeexample}
\end{command}

\begin{command}{\middleManyDots{}}
  Shortcut to add a dots and a text next to it, see more examples below.
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxX{\alpha} \middleManyDots{} & \zxX{\beta}
\end{ZX}
\end{codeexample}
\end{command}

\begin{command}{\zxLoop\opt{\oarg{direction angle}\oarg{opening angle}\oarg{other styles}}}
  Adds a loop in \meta{direction angle} (defaults to $90$), with opening angle \meta{opening angle} (defaults to $20$).
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxX{\alpha} \zxLoop{} & \zxX{} \zxLoop[45]{} & \zxX{} \zxLoop[0][30][red]{}
\end{ZX}
\end{codeexample}
\end{command}

\begin{command}{\zxLoopAboveDots\opt{\oarg{opening angle}\oarg{other styles}}}
  Adds a loop above the node with some dots.
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxX{\alpha} \zxLoopAboveDots{}
\end{ZX}
\end{codeexample}
\end{command}

\noindent The previous commands can be useful to create this figure:
\begin{codeexample}[width=0pt]% Forces code/example on two lines.
\begin{ZX}
  \leftManyDots{n} \zxX{\alpha} \zxLoopAboveDots{} \middleManyDots{} \ar[r,o'={a=75}]
      & \zxX{\beta} \zxLoopAboveDots{} \rightManyDots{m}
\end{ZX}
\end{codeexample}


\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/styles/rounded style/content vertically centered\@nil%
  \extractkey/zx/styles/rounded style/content fixed baseline\@nil%
  \extractkey/zx/styles/rounded style preload/content vertically centered\@nil%
  \extractkey/zx/styles/rounded style preload/content fixed baseline\@nil%
  \extractkey/zx/styles/rounded style preload/content fixed also frac\@nil%
  \makeatother
  \pgfmanualbody
  By default the content of the nodes are vertically centered. This can be nice to have as much space as possible around the text, but when using several nodes with letters having different height or depth, the baseline of each node won't be aligned (this is particularly visible on nodes with very high text, like |b'|):
\begin{codeexample}[width=0pt]
\begin{ZX}
  \zxX[a=start]{\alpha} & \zxX{\beta} & \zxX{a} & \zxX{b} & \zxX*{a\pi} & \zxX*{b\pi}
  & \zxX*{b'\pi} & \zxZ*{'b\pi} & \zxZ{(a \oplus b )\pi} & \zxFracX-{\pi}{4}
  & \zxFracZ{\pi}{4} & \zxZ-{\delta} & \zxZ[a=end]-{\gamma}
   \ar[from=start,to=end,on layer=background]
\end{ZX}
\end{codeexample}
Using |content fixed baseline|, it is however possible to fix the height and depth of the text to make sure the baselines are aligned (|content vertically centered| is use to come back to the default behavior). When used as a ZX option, it avoids setting this on fractions since it renders poorly. Use |content fixed baseline also frac| if you also want to fix the baseline of all fractions as well (this last style is useful only as a ZX option, since |content fixed baseline| works on all nodes).
\begin{codeexample}[width=0pt]
\begin{ZX}[content fixed baseline]
  \zxX[a=start]{\alpha} & \zxX{\beta} & \zxX{a} & \zxX{b} & \zxX*{a\pi} & \zxX*{b\pi}
  & \zxX*{b'\pi} & \zxZ*{'b\pi} & \zxZ{(a \oplus b )\pi} & \zxFracX-{\pi}{4}
  & \zxFracZ{\pi}{4} & \zxZ-{\delta} & \zxZ[a=end]-{\gamma}
   \ar[from=start,to=end,on layer=background]
\end{ZX}
\end{codeexample}
Note however that the height is really hardcoded (not sure how to avoid that) and is quite small (otherwise nodes quickly become too large), so too large content may overlay on top of the node (this is visible on the |'b\pi| node). You can use this style either on a per-picture basis (it's what we just did), on a per-node basis (just use it in the options of the node), or globally:
\begin{codeexample}[width=0pt]
\tikzset{
  /zx/user overlay/.style={
    content fixed baseline,
  },
}
\begin{ZX}
  \zxX[a=start]{\alpha} & \zxX{\beta} & \zxX{a} & \zxX{b} & \zxX*{a\pi} & \zxX*{b\pi}
  & \zxX*{b'\pi} & \zxZ*{'b\pi} & \zxZ{(a \oplus b )\pi} & \zxFracX-{\pi}{4}
  & \zxFracZ{\pi}{4} & \zxZ-{\delta} & \zxZ[a=end]-{\gamma}
   \ar[from=start,to=end,on layer=background]
\end{ZX}
\end{codeexample}
It can also be practical to combine it with |small minus|:
\begin{codeexample}[]
\begin{ZX}
  \zxZ-{\delta_j} & \zxZ[content fixed baseline]-{\delta_j} &
  \zxZ[small minus]-{\delta_j} & \zxZ[content fixed baseline,small minus]-{\delta_j}
\end{ZX}
\end{codeexample}
\end{pgfmanualentry}

\subsubsection{Phase in label style}

We also provide styles to place the phase on a label next to an empty node (not yet very well tested):

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/styles/rounded style/phase in content\@nil%
  \extractkey/zx/styles/rounded style/phase in label=style (default {})\@nil%
  \extractkey/zx/styles/rounded style/pil=style (default {})\@nil%
  \extractkey/zx/styles/rounded style/phase in label above=style (default {})\@nil%
  \extractkey/zx/styles/rounded style/pila=style (default {})\@nil%
  \extractkey/zx/styles/rounded style/phase in label below=style (default {})\@nil%
  \extractkey/zx/styles/rounded style/pilb=style (default {})\@nil%
  \extractkey/zx/styles/rounded style/phase in label right=style (default {})\@nil%
  \extractkey/zx/styles/rounded style/pilr=style (default {})\@nil%
  \extractkey/zx/styles/rounded style/phase in label left=style (default {})\@nil%
  \extractkey/zx/styles/rounded style/pill=style (default {})\@nil%
  \makeatother
  \pgfmanualbody
  The above styles are useful to place a spider phase in a label outside the node. They can either be put on the style of a node to modify a single node at a time:
\begin{codeexample}[]
  \zx{\zxX[phase in label]{\alpha} \rar & \zxX{\alpha}}
\end{codeexample}
\noindent It can also be configured on a per-figure basis:
\begin{codeexample}[]
\zx[phase in label right]{
  \zxZ{\alpha} \dar \\
  \zxX{\alpha} \dar \\
  \zxZ{}}
\end{codeexample}
\noindent or globally:
\begin{codeexample}[]
\tikzset{
  /zx/user overlay/.style={
    phase in label={label position=-45, text=purple,fill=none}
  }
}
\zx{
  \zxFracX-{\pi}{2}
}
\end{codeexample}
Note that we must use |user post preparation labels| and not |/zx/user overlay nodes| because this will be run after all the machinery for labels has been setup.

  While |phase in content| forces the content of the node to be inside the node instead of inside a label (which is the default behavior), all other styles are special cases of |phase in label|. The \meta{style} parameter can be any style made for a tikz label:
\begin{codeexample}[width=3cm]
  \zx{
    \zxX[phase in label={label position=45, text=purple}]{\alpha}
  }
\end{codeexample}

For ease of use, the special cases of label position |above|, |below|, |right| and |left| have their respective shortcut style. The |pil*| versions are shortcuts of the longer style written above. For instance, |pilb| stands for |phase in label below|. Note also that by default labels will take some space, but it's possible to make them overlay without taking space using the |overlay| label style\dots{} however do it at your own risks as it can overlay the content around (also the text before and after):
\begin{codeexample}[width=0pt]
  \zx{
    \zxZ[pilb]{\alpha+\beta} \rar & \zxX[pilb]{\gamma} \rar & \zxZ[pilb=overlay]{\gamma+\eta}
  }
\end{codeexample}
The above also works for fractions:
\begin{codeexample}[]
\zx{\zxFracX[pilr]-{\pi}{2}}
\end{codeexample}
For fractions, you can configure how you want the label text to be displayed, either in a single line (default) or on two lines, like in nodes. The function |\zxConvertToFracInLabel| is in charge of that conversion, and can be changed to your needs to change this option document-wise. To use the same notation in both content and labels, you can do:
\begin{codeexample}[width=0pt]
  Compare
  \begin{ZX}[phase in label right]
    \zxFracZ{\pi}{2} \dar \\
    \zxFracZ{a+b}[(a+b)][(c+d)]{c+d}
  \end{ZX} with
{\RenewExpandableDocumentCommand{\zxConvertToFracInLabel}{mmmmm}{
    \zxConvertToFracInContent{#1}{#2}{#3}{#4}{#5}%
  }
  \begin{ZX}[phase in label right]
    \zxFracZ{\pi}{2} \dar \\
    \zxFracZ{a+b}[(a+b)][(c+d)]{c+d}
  \end{ZX} (exact same code!)
}
\end{codeexample}
Note that in |\zxFracZ{a+b}[(a+b)][(c+d)]{c+d}| the optional arguments are useful to put parens appropriately when the fraction is written inline.
\end{pgfmanualentry}

\begin{stylekey}{/zx/defaultEnvdebug mode}
  If this macro is defined, debug mode is active. See below how it can be useful (here is a quick example).
\begin{codeexample}[width=3cm]
\begin{ZX}[debug mode]
  \rar[B] & [\zxwCol] \zxDivider[a=divTop]{} & \\
  &                                  & \zxZ[a=Ztopleft]{}
  \ar[from=divTop, to=Ztopleft]
\end{ZX}
\end{codeexample}
\end{stylekey}

\begin{command}{\zxDebugMode{}}
  If this macro is defined, debug mode is active. See below how it can be useful.
\end{command}
\begin{stylekey}{/tikz/every node/a=alias}
  Shortcut to add an |alias| to a wire, and in debug mode it also displays the alias of the nodes next to it (very practical to quickly add wires as we will see later). To enable debug mode, just type |\def\zxDebugMode{}| before your drawing, potentially in a group like |{\def\zxDebugMode{} your diagram...}| if you want to apply it to a single diagram.

  This will be very practical later when using names instead of directions to connect wires (this can improve readability and maintainability). This is added automatically in |/tikz/every node| style. Note that debug mode is effective only for |a| and not |alias|.
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX[a=A]{} & \zxZ[a=B]{\beta}
    \ar[from=A,to=B]
  \end{ZX}
  {\def\zxDebugMode{} %% Enable debug mode for next diagram%
    \begin{ZX}
      \zxX[a=A]{} & \zxZ[a=B]{\beta}
      \ar[from=A,to=B]
    \end{ZX}
  }
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/zx/defaultEnv/math baseline=node alias}
  You can easily change the default baseline which defaults to:
  \begin{verse}
    |baseline={([yshift=-axis_height]current bounding box.center)}|
  \end{verse}
  (|axis_height| is the distance to use to center equations on the ``mathematical axis'') by using this in the \meta{options} field of |\zx[options]{...}|. However, this can be a bit long to write, so |math baseline=yourAlias| is a shorcut to |baseline={([yshift=-axis_height]yourAlias)}|:
\begin{codeexample}[width=0pt]
  Compare $\begin{ZX}
    \leftManyDots{n} \zxX{\alpha} \zxLoopAboveDots{} \middleManyDots{} \ar[r,o'={a=75}]
    & \zxX{\beta} \zxLoopAboveDots{} \rightManyDots{m}
  \end{ZX}
  = {\def\zxDefaultSoftAngleS{20} % useful to make the angle in \leftManyDots{} nicer.
    \begin{ZX}
      \leftManyDots{n} \zxX{\alpha+\beta} \rightManyDots{m}
    \end{ZX}}$ with $\begin{ZX}[math baseline=wantedBaseline]
    \leftManyDots{n} \zxX{\alpha} \zxLoopAboveDots{} \middleManyDots{} \ar[r,o'={a=75}]
    %% See here --v the node chosen as the baseline
    & \zxX[a=wantedBaseline]{\beta} \zxLoopAboveDots{} \rightManyDots{m}
  \end{ZX}
  = {\def\zxDefaultSoftAngleS{20} % useful to make the angle in \leftManyDots{} nicer.
    \begin{ZX}
      \leftManyDots{n} \zxX{\alpha+\beta} \rightManyDots{m}
    \end{ZX}}$
\end{codeexample}
Also, if you find your diagram a bit ``too high'', check that you did not forget to remove a trailing |\\| at the end of the last line:
\begin{codeexample}[width=3cm]
  Compare $\begin{ZX}
    \zxZ{} \rar[o'] \rar[o.]      & \zxX{}\\
    \zxZ{} \rar[o'] \rar[o.] \rar & \zxX{}\\ %% <--- remove last \\
  \end{ZX} = \zx{\zxEmptyDiagram}$ with $\begin{ZX}
    \zxZ{} \rar[o'] \rar[o.]      & \zxX{}\\
    \zxZ{} \rar[o'] \rar[o.] \rar & \zxX{}
  \end{ZX}  = \zx{\zxEmptyDiagram}$
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/zx/defaultEnv/math baseline row=row to center}
  You can also choose directly a line to center on: for instance to center on the first line, use: |math baseline row=1|, or, equivalently |mbr=1| or directly |mbr|:
\begin{codeexample}[width=0pt]
  $\begin{ZX}[mbr]
    \zxN{} \rar[B] & [\zxwCol] \zxMatrix{A} \rar[B] &[\zxwCol] \zxN{}
  \end{ZX} = A$
\end{codeexample}
\end{stylekey}


\subsubsection{Ground}

\textbf{NB}: this functionality, based on custom nodes (\cref{subsec:customNodes}) was added on 13/03/2023.

\begin{pgfmanualentry}
  \def\extrakeytext{style, }
  \extractcommand\zxGround\oarg{picture style}\opt{.}\opt{-}\opt{'}\marg{}\@@
  \extractcommand\zxGroundScale\@@
  \pgfmanualbody
The ground symbol can be used to denote a discarding operationâ¦ but is also useful to compute the norm of a state or denote a measurement by first copying the state and discarding one copy. This way, a measurement in the computational basis can be represented as:
\begin{codeexample}[width=0pt]
  \begin{ZX}
              & [\zxwCol]                    & [\zxwCol] \zxN \rar & \zxN \\
    \zxN \rar & \zxZ{} \ar[ur,<'] \ar[dr,<'] &                            \\[\zxZeroRow]
              &                              & \zxGround{}              
  \end{ZX}
\end{codeexample}
You can also change the direction using the alternative names:
\begin{codeexample}[]
  \begin{ZX}
    \zxGround-{}\rar & \zxGround{} \\
    \zxGround'{}\dar\\
    \zxGround.{}
  \end{ZX}
\end{codeexample}
Internally, the ground symbol is drawn using a |pic|, so you can customize it as any other pic:
\begin{codeexample}[]
  \begin{ZX}
    \zxN{} \rar &[\zxwCol] \zxGround[scale=1.5,red,rotate=45]{}
  \end{ZX}
\end{codeexample}
Note that you can also redefine |\def\zxGroundScale{1.8}| to change the default scale on a whole document.
Moreover, by default the |pic| takes some space (this way it will not overlap with the next symbol, or the text below/after), but you want sometimes to make it |overlay|, for instance to preserve the symmetry with an empty wire (then, you might need to add some column space |&[yourspace]| or row space |\\[yourspace]| to avoid overlap with text around it):
\begin{codeexample}[width=0pt]
  Compare
  \begin{ZX}
                & [\zxwCol]                    & [\zxwCol] \zxN \rar & \zxN \\
    \zxN{} \rar & \zxZ{} \ar[ur,<'] \ar[dr,<'] &                            \\
                &                              & \zxGround[overlay]{}           
  \end{ZX}
  with
  \begin{ZX}
                & [\zxwCol]                    & [\zxwCol] \zxN \rar & \zxN \\
    \zxN{} \rar & \zxZ{} \ar[ur,<'] \ar[dr,<'] &                            \\
                &                              & \zxGround{}              
  \end{ZX}
\end{codeexample}
\end{pgfmanualentry}

\subsubsection{Scalable ZX}

We provide some notations coming from the scalable ZX calculus~\cite{CHP19_SZXcalculusScalableGraphical}. 

\begin{pgfmanualentry}
  \def\extrakeytext{style, }
  \extractcommand\zxDivider\oarg{picture style}\oarg{picture style}\opt{.}\opt{-}\opt{'}\marg{}\@@
  \pgfmanualbody
  Dividers can be used to split (or gather) groups of wires. The |.|,|-|,|'| modifiers are used, respectively, to denote the bottom/right/top versions:
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
We provide some pre-defined symbols in both horizontal: %
\begin{ZX}
  \zxZ[B]{} \rar[Bn'=n+m, wc] &[\zxwCol] \zxDivider{} 
                                  \rar[o',Bn'Args={n}{}]
                                  \rar[o.,Bn.Args={m}{}] &[\zxWCol] \zxDivider-{} \rar[B,wc] & \zxZ[B]{}
\end{ZX}
 and vertical mode:
\begin{ZX}
  \zxZ[B]{} \dar[Bn=n+m, wc] \\[\zxwRow]
  \zxDivider'{} \dar[-o,BnArgs={n}{}] \dar[o-,Bn-Args={m}{}] \\[\zxWRow]
  \zxDivider.{} \dar[B,wc]\\
  \zxZ[B]{}
\end{ZX}
\end{codeexample}
}
\end{pgfmanualentry}


\begin{pgfmanualentry}
  \def\extrakeytext{style, }
  \extractcommand\zxMatrix\oarg{pic style}\oarg{node style}\opt{.}\opt{-}\opt{'}\opt{/}\opt{*}\opt{\_\{text in pmatrix\}}\marg{matrix name}\@@
  \pgfmanualbody
  Matrices are represented using arrows: |matrix name| is the content of the label of the node:
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[]
\begin{ZX}
  \zxN{} \rar & \zxMatrix{A} \rar & \zxN{}
\end{ZX}
\end{codeexample}
}
The |*| option is used to reverse the direction of the arrow, typically for the transpose (note how we can give an alias (with |a| in |node style|) to combine with |math baseline|, or its quicker variants |mbr=nb line to center on| to properly vertically align the node):
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
We define %
$\begin{ZX}[mbr]
  \zxN{} \rar[B] & \zxMatrix*{A} \rar[B] & \zxN{}
\end{ZX} \coloneqq
\begin{ZX}[mbr=2]
            & [\zxWCol] \zxN{} \ar[B,dr,s]        & [\zxWCol] \zxN{} \\[\zxZeroCol+.3mm]
\ar[B,dr,s] & \zxMatrix{A} \ar[B,u,C] \ar[B,d,C-] &                  \\
            &                                     & \zxN{}           \\
\end{ZX}$.
\end{codeexample}
}
The position of the label can be changed with |-| is in horizontal wires, and in vertical wires we use |'| and |.| (putting the label respectively on right and left).
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
\begin{ZX}
  \zxN{} \rar & \zxMatrix{} \rar & \zxMatrix{A} \rar & \zxMatrix*{A} \rar
  & \zxMatrix-{A} \rar & \zxMatrix-*{A} \rar & \zxN{}
\end{ZX}
\end{codeexample}
}
Similarly in horizontal wires:
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[]
\begin{ZX}
  \zxN{} \dar \\
  \zxMatrix'{} \dar \\
  \zxMatrix.{A} \dar \\
  \zxMatrix'*{A} \dar \\
  \zxMatrix'{A} \dar \\
  \zxMatrix.*{A} \dar \\
  \zxN{}
\end{ZX}
\end{codeexample}
}
If you want to change the position of the label to a more advanced position (e.g.\ with an angle), the simpler solution is to add |yourAngle:| in front of the label (see tikz labels for more details):
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[]
\begin{ZX}
  \zxZ{} \rar & \zxMatrix{45:A} \rar & \zxN{}
\end{ZX}
\end{codeexample}
}
Note that it might be useful to put the label as an overlay using |/| (i.e. it is not counted in the bounding box of the cell, and might overlap with content around) in order to reduce space if we know there is nothing on the nearby cell: (we can also manually change the row/colum sep with negative valuesâ¦ but it might be better to avoid this kind of manual tweaks):
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[]
Compare %
\begin{ZX}
  \zxZ{} \rar \dar & \zxMatrix-{A} \rar & \zxN{} \\
  \zxX{}
\end{ZX} with %
\begin{ZX}
  \zxZ{} \rar \dar & \zxMatrix-/{A} \rar & \zxN{} \\
  \zxX{}
\end{ZX}
\end{codeexample}
}
It is also useful to put a |pmatrix| inside. While it is possible to write the full |pmatrix|, we can use the |_{}| embelishment to automatically wrap the text with |\begin{bmatrix} \end{bmatrix}|:
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
This %
\begin{ZX}[mbr]
  \zxN{} \rar & \zxMatrix_{A & B \\ C & D}{} \rar & \zxN{}
\end{ZX} %
is a shortcut for %
\begin{ZX}[math baseline row=1]
  \zxN{} \rar & \zxMatrix{\begin{bmatrix} A & B \\ C & D \end{bmatrix}} \rar & \zxN{}
\end{ZX}
\end{codeexample}
}
Note that it seems that some environments do not play well with the way we handle |&| (our changes were needed to make them compatible with |align|, and to provide an easy interface with the |external| libraryâ¦ but it seems to not fit well with all environments, e.g.\ arrays). In that case you should use |\begin{ZXNoExt}| together with |[ampersand replacement=\&]| (of course, use |\&| instead of |&| in the rest of the matrix):
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
$\begin{ZXNoExt}[ampersand replacement=\&]
  \zxN{} \rar \& \zxMatrix{
    \begin{bmatrix}
      \begin{array}{c|c}
        A & B \\
        \hline
        C & D
      \end{array}
    \end{bmatrix}} \rar \& \zxN{}
\end{ZXNoExt}$
\end{codeexample}
}
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \def\extrakeytext{style, }
  \makeatletter% should not be letter for \@@... strange
  \extractkey/zx/picCustomStyleMatrixMainNode\@nil%
  \extractkey/zx/picCustomStyleMatrixLabel\@nil%
  \extractkey/zx/picCustomStyleBeforeUserMatrix\@nil%
  \extractkey/zx/picCustomStyleAterUserMatrix\@nil%
  \extractkey/zx/picCustomStyleLastPicMatrix\@nil%
  \makeatother
  \pgfmanualbody
If you would like to override some settings, note that you can use all customization options provided by our custom node system (\cref{subsec:customNodes}). In particular, you can use |pic style| to change the options of the pic used to draw the node, including scale, rotationâ¦, |node style| to style the parent node of the pic (less used, mostly to give alias names to the shape). We additionally provide special styles to configure the nodes more precisely: |/zx/picCustomStyleMatrixMainNode| and |/zx/picCustomStyleMatrixLabel| to configure more specifically the :
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
\begin{ZX}
  \zxN{} \rar & \zxMatrix{A} \rar &
  \zxMatrix[
    scale=2,
    /zx/picCustomStyleMatrixMainNode/.style={fill=blue!50},
    /zx/picCustomStyleMatrixLabel/.style={red}]{A}
  \rar & \zxN{}
\end{ZX}
\end{codeexample}
}
You can also set globally the styles like |/zx/picCustomStyleBeforeUserMatrix| (automatically provided, see details in \cref{subsec:customNodes}) to automatically add a style to your picture :
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
\tikzset{
  /zx/picCustomStyleBeforeUserMatrix/.style={
    scale=2,
    /zx/picCustomStyleMatrixMainNode/.style={fill=blue!50},
    /zx/picCustomStyleMatrixLabel/.style={red,circle,draw,inner sep=1pt},
    % \zxCustomPicAdditionalPic can be any tikz code to run after the creation of the pic:
    /utils/exec={\def\zxCustomPicAdditionalPic{%
        % the main node has empty name, so .center is the center of the main node
        \node[draw,circle,inner sep=2pt,fill=pink] at (.center) {};%
      }%
    },
  },
}
\begin{ZX}
  \zxZ{} \rar & \zxMatrix{A} \rar & \zxMatrix*{B} \rar & \zxN{}
\end{ZX}
\end{codeexample}
}
\end{pgfmanualentry}

\subsubsection{Miscellaneous}

\begin{pgfmanualentry}
  \def\extrakeytext{style, }
  \extractcommand\zxBox\marg{box text}\@@
  \pgfmanualbody
  You can add simple boxes using |\zxBox{X}| (in math mode), possibly adding additional styling to the main box using |main={your style}|:
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[]
\begin{ZX}
  \zxBox{G} \rar[B]                    & [\zxwCol] \zxN{}\\
  \zxBox[main={fill=green}]{G_A} \rar[B] & [\zxwCol] \zxN{}
\end{ZX}
\end{codeexample}
}
\end{pgfmanualentry}

\subsection{Wires}

\subsubsection{Creating wires and debug mode}

\begin{pgfmanualentry}
  \extractcommand\arrow\opt{\oarg{options}}\@@
  \extractcommand\ar\opt{\oarg{options}}\@@
  \pgfmanualbody
  These synonym commands (actually coming from |tikz-cd|) are used to draw wires between nodes. We refer to |tikz-cd| for an in-depth documentation, but what is important for our purpose is that the direction of the wires can be specified in the \meta{options} using a string of letters |r| (right), |l| (left), |u| (up), |d| (down). It's also possible to specify a node alias as a source or destination as shown below.
\begin{codeexample}[]
\zx{\zxZ{} \ar[r] & \zxX{}} = \zx{\zxX{} \arrow[rd] \\ & \zxZ{}}
\end{codeexample}
  \meta{options} can also be used to add any additional style, either custom ones, or the ones defined in this library (this is recommended since it can be easily changed document-wise by simply changing the style). Multiple wires can be added in the same cell. Other shortcuts provided in |tikz-cd| like |\rar|\dots{} can be used.
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
\begin{ZX}
  \zxZ{\alpha} \arrow[d, C] % C = Bell-like wire
               \ar[r,H,o']  % o' = top part of circle
               % H adds Hadamard, combine with \zxHCol
               \ar[r,H,o.] &[\zxHCol] \zxZ{\gamma}\\
  \zxZ{\beta}  \rar        & \zxX{} \ar[ld,red,"\circ" {marking,blue}] \ar[rd,s] \\
  \zxFracX-{\pi}{4}        & &\zxZ{}
\end{ZX}
\end{codeexample}
}
\end{pgfmanualentry}

As explained in |tikz-cd|, there are further shortened forms:
\begin{pgfmanualentry}
  \extractcommand\rar\opt{\oarg{options}}\@@
  \extractcommand\lar\opt{\oarg{options}}\@@
  \extractcommand\dar\opt{\oarg{options}}\@@
  \extractcommand\uar\opt{\oarg{options}}\@@
  \extractcommand\drar\opt{\oarg{options}}\@@
  \extractcommand\urar\opt{\oarg{options}}\@@
  \extractcommand\dlar\opt{\oarg{options}}\@@
  \extractcommand\ular\opt{\oarg{options}}\@@
  \pgfmanualbody
\end{pgfmanualentry}
The first one is equivalent to
\begin{verse}
  |\arrow|{\oarg{options}}|{r}|
\end{verse}
and the other ones work analogously.

Note that sometimes, it may be practical to properly organize big diagrams to increase readability. To that end, one surely wants to have a small and well indented matrix (emacs |M-x align-current| or |M-x align| (for selected lines) commands are very practical to indent matrices automatically). Unfortunately, adding wires inside the matrix can make the line really long and hard to read. Similarly, some nodes involving fractions or long expressions can also be quite long. It is however easy to increase readability (and maintainability) by moving the wires at the very end of the diagram, using |a| (like |alias|, but with a debug mode) to connect nodes and |\def| to create shortcuts. Putting inside a macro with |\def| long node definitions can also be useful to keep small items in the matrix:
\begin{codeexample}[width=0pt]
\begin{ZX}[zx row sep=1pt,
  execute at begin picture={%
    %%% Definition of long items (the goal is to have a small and readable matrix
    % (warning: macro can't have numbers in TeX. Also, make sure not to use existing names)
    \def\Zpifour{\zxFracZ[a=Zpi4]-{\pi}{4}}%
    \def\mypitwo{\zxFracX[a=mypi2]{\pi}{2}}%
  }
  ]
  %%% Matrix: in emacs "M-x align-current" is practical to automatically format it.
  %%% a is for 'alias'... but also provides a debug mode, see below.
                &              &                   &                 & \zxZ[a=toprightpi]{\pi} \\
  \zxN[a=in1]{} & \zxX[a=X1]{} &                   &                 &  & \zxN[a=out1]{}       \\
                &              & \zxZ[a=xmiddle]{} & \mypitwo{}      &  & \zxN[a=out2]{}       \\
  \zxN[a=in2]{} & \Zpifour{}   &                   & \zxX[a=Xdown]{} &  & \zxN[a=out3]{}
  %%% Arrows
  % Column 1
  \ar[from=in1,to=X1]
  \ar[from=in2,to=Zpi4]
  % Column 2
  \ar[from=X1,to=xmiddle,(.]
  \ar[from=X1,to=toprightpi,<',H]
  \ar[from=Zpi4,to=xmiddle,(']
  \ar[from=Zpi4,to=Xdown,o.]
  % Column 3
  \ar[from=xmiddle,to=Xdown,s.]
  \ar[from=xmiddle,to=mypi2]
  % Column 4
  \ar[from=mypi2,to=toprightpi,(']
  \ar[from=mypi2,to=out1,<']
  \ar[from=mypi2,to=out2]
  \ar[from=Xdown,to=out3]
\end{ZX}
\end{codeexample}
In that setting, it is often useful to enable the debug mode via |\def\zxDebugMode{}| as explained above to quickly visualize the alias given to each node (note that debug mode works with |a=| but not with |alias=|). For instance, it was easy to rewrite the above diagram by moving nodes in the matrix and arrows after checking their name on the produced pdf (NB: you can increase |column sep| and |row sep| temporarily to make the debug information more visible):
\begin{codeexample}[width=0pt]
{
  \def\zxDebugMode{}%%%%
  \begin{ZX}[zx row sep=1pt,
    execute at begin picture={%
      %%% Definition of long items (the goal is to have a small and readable matrix
      % (warning: macro can't have numbers in TeX. Also, make sure not to use existing names)
      \def\Zpifour{\zxFracZ[a=Zpi4]-{\pi}{4}}%
      \def\mypitwo{\zxFracX[a=mypi2]{\pi}{2}}%
    }
    ]
    %%% Matrix: in emacs "M-x align" is practical to automatically format it. a is for 'alias'
    & \zxN[a=n]{}  & \zxZ[a=xmiddle]{}       &            & \zxN[a=out1]{} \\
    \zxN[a=in1]{} & \Zpifour{}   & \zxX[a=Xdown]{}         & \mypitwo{} &                \\
    &              &                         &            & \zxN[a=out2]{} \\
    \zxN[a=in2]{} & \zxX[a=X1]{} & \zxZ[a=toprightpi]{\pi} &            & \zxN[a=out3]{}
    %%% Arrows
    % Column 1
    \ar[from=in1,to=X1,s]
    \ar[from=in2,to=Zpi4,.>]
    % Column 2
    \ar[from=X1,to=xmiddle,N']
    \ar[from=X1,to=toprightpi,H]
    \ar[from=Zpi4,to=n,C] \ar[from=n,to=xmiddle,wc]
    \ar[from=Zpi4,to=Xdown]
    % Column 3
    \ar[from=xmiddle,to=Xdown,C-]
    \ar[from=xmiddle,to=mypi2,)]
    % Column 4
    \ar[from=mypi2,to=toprightpi,(']
    \ar[from=mypi2,to=out1,<']
    \ar[from=mypi2,to=out2,<.]
    \ar[from=Xdown,to=out3,<.]
  \end{ZX}
}
\end{codeexample}

\subsubsection{Wire styles (new generation)}

We give now a list of wire styles provided in this library (|/zx/wires definition/| is an automatically loaded style). We recommend using them instead of manual styling to ensure they are the same document-wise, but they can of course be customized to your need. Note that the name of the styles are supposed (ahah, I do my best with what ASCII provides) to graphically represent the action of the style, and some characters are added to precise the shape: typically |'| means top, |.| bottom, |X-| is right to X (or should arrive with angle 0), |-X| is left to X (or should leave with angle zero). These shapes are usually designed to work when the starting node is left most (or above of both nodes have the same column). But they may work both way for some of them.

Note that the first version of that library (which appeared one week before this new version\dots{} hopefully backward compatibility won't be too much of a problem) was using |in=| and |out=| to create these styles. However, it turns out to be not very reliable since the shape of the wire was changing (sometimes importantly) depending on the position of the nodes. This new version should be more reliable, but the older styles are still available by using |IO, nameOfWirestyle| (read more in \cref{subsub:IOwires}).

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/C=radius ratio (default 1)\@nil%
  \extractkey/zx/wires definition/C.=radius ratio (default 1)\@nil%
  \extractkey/zx/wires definition/C'=radius ratio (default 1)\@nil%
  \extractkey/zx/wires definition/C-=radius ratio (default 1)\@nil%
  \makeatother
  \pgfmanualbody
  Bell-like wires with an arrival at ``right angle'', |C| represents the shape of the wire, while |.| (bottom), |'| (top) and |-| (side) represent (visually) its position. Combine with |wire centered| (|wc|) to avoid holes when connecting multiple wires (not required with |\zxNone{}|, alias |\zxN{}|).
\begin{codeexample}[]
  A Bell pair \zx{\zxNone{} \ar[d,C] \\[\zxWRow]
                \zxNone{}}
  , a swapped Bell pair
  \begin{ZX}
    \zxN{} \ar[d,C] \ar[rd,s] &[\zxWCol] \zxN{} \\[\zxWRow]
    \zxN{}          \ar[ru,s] &          \zxN{}
  \end{ZX}
  and a funny graph
  \begin{ZX}
    \zxX{} \ar[d,C] \ar[r,C']  & \zxZ{} \ar[d,C-]\\
    \zxZ{} \ar[r,C.]           & \zxX{}
  \end{ZX}.
\end{codeexample}
Note that this style is actually connecting the nodes using a perfect circle (it is \emph{not} based on |curve to|), and therefore should \emph{not} be used together with |in|, |out|, |looseness|\dots{} (this is the case also for most other styles except the ones in |IO|). It has the advantage of connecting nicely nodes which are not aligned or with different shapes:
\begin{codeexample}[]
  \begin{ZX}
    \zxX{\alpha} \ar[dr,C]\\
    & \zxNone{}
  \end{ZX}
\end{codeexample}
The \meta{radius ratio} parameter can be used to turn the circle into an ellipse using this ratio between both axis:
\begin{codeexample}[]
  \begin{ZX}
    \zxX{\alpha}
      \ar[dr,C=0.5,red]
      \ar[dr,C,green]
      \ar[dr,C=2,blue]
      \ar[dr,C=3,purple]\\
                        & \zxNone{}
  \end{ZX}
  \begin{ZX}
    \zxX{} \ar[d,C=2] \ar[r,C'=2]  & \zxZ{} \ar[d,C-=2,H]\\
    \zxZ{} \ar[r,C.=2]           & \zxX{}
  \end{ZX}.
\end{codeexample}
\end{pgfmanualentry}


\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/o'=angle (default 40)\@nil%
  \extractkey/zx/wires definition/o.=angle (default 40)\@nil%
  \extractkey/zx/wires definition/o-=angle (default 40)\@nil%
  \extractkey/zx/wires definition/-o=angle (default 40)\@nil%
  \makeatother
  \pgfmanualbody
  Curved wire, similar to |C| but with a soften angle (optionally specified via \meta{angle}, and globally editable with |\zxDefaultLineWidth|). Again, the symbols specify which part of the circle (represented with |o|) must be kept.
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{} \ar[d,-o] \ar[d,o-]\\
    \zxZ{} \ar[r,o'] \ar[r,o.] & \zxX{}
  \end{ZX}.
\end{codeexample}
 Note that these wires can be combined with |H|, |X| or |Z|, in that case one should use appropriate column and row spacing as explained in their documentation:
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{\alpha} \ar[d,-o,H] \ar[d,o-,H]\\[\zxHRow]
    \zxZ{\beta} \rar & \zxZ{} \ar[r,o',X] \ar[r,o.,Z] &[\zxSCol] \zxX{}
  \end{ZX}.
\end{codeexample}
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/(=angle (default 30)\@nil%
  \extractkey/zx/wires definition/)=angle (default 30)\@nil%
  \extractkey/zx/wires definition/('=angle (default 30)\@nil%
  \extractkey/zx/wires definition/('=angle (default 30)\@nil%
  \makeatother
  \pgfmanualbody
  Curved wire, similar to |o| but can be used for diagonal items. The angle is, like in |bend right|, the opening angle from the line which links the two nodes. For the first two commands, the |(| and |)| symbols must be imagined as if the starting point was on top of the parens, and the ending point at the bottom.
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{} \ar[rd,(] \ar[rd,),red]\\
    & \zxZ{}
  \end{ZX}.
\end{codeexample}
Then, |('|=|(| and |(.|=|)|; this notation is, I think, more intuitive when linking nodes from left to right. |('| is used when going to top right and |(.| when going to bottom right.
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxN{}                       & \zxX{}\\
  \zxZ{} \ar[ru,('] \ar[rd,(.] & \\
                               & \zxX{}
\end{ZX}
\end{codeexample}
When the nodes are too far appart, the default angle of |30| may produce strange results as it will go above (for |('|) the vertical line. Either choose a shorter angle, or see |<'| instead. Note that for now this node is based on |in| and |out|, but it may change later. So if you want to change looseness, or really rely on the precise specified angle, prefer to use |IO,(| instead (which takes the |IO| version, guaranteed to stay untouched).
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/start fake center north\@nil%
  \extractkey/zx/wires definition/start fake center south\@nil%
  \extractkey/zx/wires definition/start fake center east\@nil%
  \extractkey/zx/wires definition/start fake center west\@nil%
  \extractkey/zx/wires definition/start real center\@nil
  \extractkey/zx/wires definition/end fake center north\@nil%
  \extractkey/zx/wires definition/end fake center south\@nil%
  \extractkey/zx/wires definition/end fake center east\@nil%
  \extractkey/zx/wires definition/end fake center west\@nil%
  \extractkey/zx/wires definition/end real center\@nil
  \extractkey/zx/wires definition/left to right\@nil%
  \extractkey/zx/wires definition/right to left\@nil%
  \extractkey/zx/wires definition/up to down\@nil%
  \extractkey/zx/wires definition/down to up\@nil%
  \extractkey/zx/wires definition/force left to right\@nil%
  \extractkey/zx/wires definition/force right to left\@nil%
  \extractkey/zx/wires definition/force up to down\@nil%
  \extractkey/zx/wires definition/force down to up\@nil%
  \extractkey/zx/wires definition/no fake center\@nil%
  \makeatother
  \pgfmanualbody
  Usually each wire should properly use these functions, so the end user should not need that too often (during a first reading, you can skip this paragraph). We added 4 anchors to nodes: |fake center north|, |fake center south|, |fake center east| and |fake center west|. These anchors are used to determine the starting point of the wires depending on the direction of the wire. Because some nodes may not have these anchors, we can't directly set |start anchor=fake center north, on layer=edgelayer| (but the user can do that if they are using only nodes with these anchors) or the code may fail on some nodes. For that reason, we check that these anchors exist while drawing our wires (which, at the best of my knowledge, can only be done while drawing the path). The |start/end fake center *| code is responsible to configure that properly (|start real center| will use the real center), and |left to right| (and similar) just configure both the |start| and |end| point to ensure the node starts at the appropriate anchor. However this won't work for style not defined in this library: in case you are sure that these anchors exists and want to use your own wire styles, you can then set the anchors manually and use |on layer=edgelayer|, or use |force left to right| (and similar) which will automatically do that for the |start| and |end| points.
\begin{codeexample}[]
\begin{ZX}
  \zxX{\alpha+\beta} \ar[r,o',no fake center] & \zxZ{\alpha+\beta}\\
  \zxX{\alpha+\beta} \ar[r,o'] & \zxZ{\alpha+\beta}
\end{ZX}
\end{codeexample}
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/args/-andL/-=x\@nil%
  \extractkey/zx/args/-andL/1-=x\@nil%
  \extractkey/zx/args/-andL/2-=x\@nil%
  \extractkey/zx/args/-andL/L=y\@nil%
  \extractkey/zx/args/-andL/1L=y\@nil%
  \extractkey/zx/args/-andL/2L=y\@nil%
  \extractkey/zx/args/-andL/1 angle and length=\marg{angle}\marg{length}\@nil%
  \extractkey/zx/args/-andL/1al=\marg{angle}\marg{length}\@nil%
  \extractkey/zx/args/-andL/2 angle and length=\marg{angle}\marg{length}\@nil%
  \extractkey/zx/args/-andL/2al=\marg{angle}\marg{length}\@nil%
  \extractkey/zx/args/-andL/angle and length=\marg{angle}\marg{length}\@nil%
  \extractkey/zx/args/-andL/al=\marg{angle}\marg{length}\@nil%
  \extractkey/zx/args/-andL/1 angle=\marg{angle}\@nil%
  \extractkey/zx/args/-andL/1a=\marg{angle}\@nil%
  \extractkey/zx/args/-andL/2 angle=\marg{angle}\@nil%
  \extractkey/zx/args/-andL/1a=\marg{angle}\marg{length}\@nil%
  \extractkey/zx/args/-andL/angle=\marg{angle}\@nil%
  \extractkey/zx/args/-andL/a=\marg{angle}\@nil%
  \extractkey/zx/args/-andL/symmetry-L\@nil%
  \extractkey/zx/args/-andL/symmetry\@nil%
  \extractkey/zx/args/-andL/negate1L\@nil%
  \extractkey/zx/args/-andL/negate2L\@nil%
  \extractkey/zx/args/-andL/negateL\@nil%
  \extractkey/zx/args/-andL/negate1-\@nil%
  \extractkey/zx/args/-andL/negate2-\@nil%
  \extractkey/zx/args/-andL/negate-\@nil%
  \extractkey/zx/args/-andL/oneMinus1-\@nil%
  \extractkey/zx/args/-andL/oneMinus2-\@nil%
  \extractkey/zx/args/-andL/oneMinus1L\@nil%
  \extractkey/zx/args/-andL/oneMinus2L\@nil%
  \makeatother
  \pgfmanualbody
  The next wires can take multiple options. They are all based on the same set of options for now, namely |/zx/args/-andL/|. The |1*| options are used to configure the starting point, the |2*| to configure the ending point, if no number is given both points are updated. |-| and |L| are used to place two anchors of a Bezier curve. They are expressed in relative distance (so they are typically between $0$ and $1$, but can be pushed above $1$ or below $0$ for stronger effects), |-| is typically on the |x| axis and |L| on the |y| axis (the name represents ``graphically'' the direction). They are however not named |x| and |y| because some wires use them slighlty differently, notably |o| which uses |-| for the direction of the arrow and |L| for the direction perpendicular to the arrow (again the shape of |L| represents a perpendicular line). Each wire interprets |-| and |L| to ensure that $0$ should lead to a straight line, and that a correct shape is obtained when |1-| equals |2-|, |1L| equals |2L| (except for non-symmetric shapes of course), and both |-| and |L| are positive.

  The other expressions involving |angle| (or the shortcut |a|) allow you to define |1-|,|1L|\dots{} using a maybe more intuitive ``polar'' notation, i.e.\ an ``angle'' and a relative length (if not specified, like in |1 angle|, the length defaults to $0.6$). Note that the angle is not really an angle (it is an angle only when the nodes are placed at $45$ degrees, or for the |bezier x/y| variations), but a ``squeezed angle'' (when nodes are not at $45$ degrees, the shape is squeezed horizontally or vertically not to change the wire) and similarly for the length. In the above list, the meaning of each expression should be clear from the name: for instance |1angle and length={45}{.8}| will setup a squeezed angle of $45$ and a relative length of $.8$ for the first point, i.e.\ this is equivalent to $1-=.8\cos(45)$ and $1L=.8\sin(45)$, and |angle=45| will change the angle of both points to $45$, with a relative length of $.6$. In the above list, each long expression has below it a shorter version, for intance |a=45| is equivalent to |angle=45|.

  The last expressions (|symmetry-L|, |symmetry|\dots) are used internally to do some math. Of course if you need to do symmetries at some point you can use these keys (|symmetry-L| exchange |-| and |L|, and |symmetry| exchanges |1| and |2|), |negateX| just negates |X| and |oneMinusX| replaces |X| with |1-X|. Each of the following nodes have default values which can be configured as explained in \cref{subsec:wirecustom}.
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/s=-andL config (default defaultS)\@nil%
  \extractkey/zx/wires definition/s'=-andL config (default defaultS')\@nil%
  \extractkey/zx/wires definition/s.=-andL config (default defaultS')\@nil%
  \extractkey/zx/wires definition/-s=-andL config (default default-S)\@nil%
  \extractkey/zx/wires definition/-s'=-andL config (default \{defaultS',default-S\})\@nil%
  \extractkey/zx/wires definition/-s.=-andL config (default \{defaultS',default-S\})\@nil%
  \extractkey/zx/wires definition/s-=-andL config (default \{defaultS',default-S,symmetry\})\@nil%
  \extractkey/zx/wires definition/s'-=-andL config (default \{defaultS',default-S,symmetry\})\@nil%
  \extractkey/zx/wires definition/s.-=-andL config (default \{defaultS',default-S,symmetry\})\@nil%
  \extractkey/zx/wires definition/-S=-andL config (default \{defaultS',default-S\})\@nil%
  \extractkey/zx/wires definition/-S'=-andL config (default \{defaultS',default-S\})\@nil%
  \extractkey/zx/wires definition/-S.=-andL config (default \{defaultS',default-S\})\@nil%
  \extractkey/zx/wires definition/S-=-andL config (default \{defaultS',default-S,symmetry\})\@nil%
  \extractkey/zx/wires definition/S'-=-andL config (default \{defaultS',default-S,symmetry\})\@nil%
  \extractkey/zx/wires definition/S.-=-andL config (default \{defaultS',default-S,symmetry\})\@nil%
  \makeatother
  \pgfmanualbody
  |s| and |S| are used to create a s-like wire, to have nicer diagonal lines between nodes. Other versions are soften versions (the input and output angles are not as sharp. Adding |'| or |.| specifies if the wire is going up-right or down-right, however as of today if it mostly used for backward compatibility since, for instance, |-s'| is the same as |-s| (but some styles may want to do a difference later). The only exception is for |s|/|s'|/|s.|: |s| has a sharper output angle than |s'| and |s.| (which are both equals).
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{\alpha} \ar[s,rd] \\
                           & \zxZ{\beta}\\
    \zxX{\alpha} \ar[s.,rd] \\
                           & \zxZ{\beta}\\
                           & \zxZ{\alpha}\\
    \zxX{\beta} \ar[S,ru] \\
                           & \zxZ{\alpha}\\
    \zxX{\beta} \ar[s',ru] \\
  \end{ZX}
\end{codeexample}
|-| forces the angle on the side of |-| to be horizontal. Because for now the wires start inside the node, this is not very visible. For that reason, versions with a capital |S| have an anchor on the side of |-| lying on the surface of the node (|S| has two such anchors since both inputs and outputs arrives horizontally) instead of on the |fake center *| anchor (see explanation on |fake center| anchors above).
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{\alpha} \ar[s.,rd] \\
                           & \zxZ{\beta}\\
    \zxX{\alpha} \ar[-s.,rd] \\
                           & \zxZ{\beta}\\
    \zxX{\alpha} \ar[s.-,rd] \\
                           & \zxZ{\beta}\\
    \zxX{\alpha} \ar[S,rd] \\
                           & \zxZ{\beta}\\
  \end{ZX}
\end{codeexample}
It is possible to configure it using the options in |-andL config| as explained above (default values are given in \cref{subsec:wirecustom}), where |-| is the (relative) position of the horizontal Bezier anchor and |L| its relative vertical position (to keep a |s|-shape, you should have |-|$>$|L|).
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxX{\alpha} \ar[rd,s.] \\
  & \zxZ{\beta}\\
  % same as s., configure globally using defaultS'\\
  \zxX{\alpha} \ar[rd,s.={-=.8,L=.2}]\\
                 & \zxZ{\beta}\\
  \zxX{\alpha} \ar[rd,s.={L=.4}] \\
                 & \zxZ{\beta}\\
  \zxX{\alpha} \ar[rd,s.={L=0.1,-=1}] \\
                 & \zxZ{\beta}\\
  \zxX{\alpha} \ar[rd,edge above, control points visible,s.={-=2}] \\
                 & \zxZ{\beta}
\end{ZX}
\end{codeexample}
For the non-symmetric versions (involving a vertical arrival), you can configure each point separately using |1-| and |1L| (first point) and |2-| and |2L| (second points). You can also specify the ``squeezed angle'' and ``length'' of each point, for instance using the |1 angle and length={10}{.8}| option (short version is |1al={10}{.8}|) or both at the same time using |al={10}{.6}| (this last command being itself equivalent to |a=10|). As explained later |edge above| and |control points visible| can help you to visualize the control points of the underlying Bezier curve.
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxZ{} \ar[dr,s.={al={10}{.8}}]\\ &\zxZ{}\\
    \zxZ{} \ar[edge above,control points visible,dr,s.={a=10}]\\ &\zxZ{}
  \end{ZX}
\end{codeexample}
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/ss=-andL config (default \{defaultS,symmetry-L\})\@nil%
  \extractkey/zx/wires definition/SS=-andL config (default \{defaultS,symmetry-L\})\@nil%
  \extractkey/zx/wires definition/ss.=-andL config (default \{defaultS',symmetry-L\})\@nil%
  \extractkey/zx/wires definition/.ss=-andL config (default \{defaultS',symmetry-L\}30)\@nil%
  \extractkey/zx/wires definition/sIs.=-andL config (default defaultSIS)\@nil%
  \extractkey/zx/wires definition/.sIs=-andL config (default \{defaultS',defaultSIS\})\@nil%
  \extractkey/zx/wires definition/ss.I-=-andL config (default \{defaultS',defaultSIS,symmetry\})\@nil%
  \extractkey/zx/wires definition/I.ss-=-andL config (default \{defaultS',defaultSIS,symmetry\})\@nil%
  \extractkey/zx/wires definition/SIS=-andL config (default \{defaultS',defaultSIS\})\@nil%
  \extractkey/zx/wires definition/.SIS=-andL config (default \{defaultS',defaultSIS\})\@nil%
  \extractkey/zx/wires definition/ISS=-andL config (default \{defaultS',defaultSIS,symmetry\})\@nil%
  \extractkey/zx/wires definition/SS.I=-andL config (default \{defaultS',defaultSIS,symmetry\})\@nil%
  \extractkey/zx/wires definition/I.SS=-andL config (default \{defaultS',defaultSIS,symmetry\})\@nil%
  \extractkey/zx/wires definition/SSI=-andL config (default \{defaultS',defaultSIS,symmetry\})\@nil%
  \makeatother
  \pgfmanualbody
  |ss| is similar to |s| except that we go from top to bottom instead of from left to right. The position of |.| says if the node is wire is going bottom right (|ss.|) or bottom left (|.ss|).
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{\alpha} \ar[ss,rd] \\
                           & \zxZ{\beta}\\
    \zxX{\alpha} \ar[ss.,rd] \\
                           & \zxZ{\beta}\\
                           & \zxX{\beta} \ar[.ss,dl] \\
    \zxZ{\alpha}\\
                           & \zxX{\beta} \ar[.ss={},dl] \\
    \zxZ{\alpha}\\
  \end{ZX}
\end{codeexample}
|I| forces the angle above (if in between the two |s|) or below (if on the same side as |.|) to be vertical.
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{\alpha} \ar[ss,rd] \\
                           & \zxZ{\beta}\\
    \zxX{\alpha} \ar[sIs.,rd] \\
                           & \zxZ{\beta}\\
    \zxX{\alpha} \ar[ss.I,rd] \\
                           & \zxZ{\beta}\\
                           & \zxX{\beta} \ar[.sIs,dl] \\
    \zxZ{\alpha}\\
                           & \zxX{\beta} \ar[I.ss,dl] \\
    \zxZ{\alpha}\\
  \end{ZX}
\end{codeexample}
The |S| version forces the anchor on the vertical line to be on the boundary.
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{\alpha} \ar[SS,rd] \\
                           & \zxZ{\beta}\\
    \zxX{\alpha} \ar[SIS,rd] \\
                           & \zxZ{\beta}\\
    \zxX{\alpha} \ar[SSI,rd] \\
                           & \zxZ{\beta}\\
                           & \zxX{\beta} \ar[.sIs,dl] \\
    \zxZ{\alpha}\\
                           & \zxX{\beta} \ar[I.ss,dl] \\
    \zxZ{\alpha}\\
  \end{ZX}
\end{codeexample}
As for |s| it can be configured:
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxX{\alpha} \ar[rd,SIS] \\
                             & \zxZ{\beta}\\
  \zxX{\alpha} \ar[rd,SIS={1L=.4}] \\
                             & \zxZ{\beta}\\
  \zxX{\alpha} \ar[rd,SIS={1L=.8}] \\
                             & \zxZ{\beta}\\
  \zxX{\alpha} \ar[rd,SIS={1L=1,2L=1}] \\
                             & \zxZ{\beta}\\
\end{ZX}
\end{codeexample}
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/N=-andL config (default defaultN)\@nil%
  \extractkey/zx/wires definition/N'=-andL config (default defaultN)\@nil%
  \extractkey/zx/wires definition/N.=-andL config (default defaultN)\@nil%
  \extractkey/zx/wires definition/-N=-andL config (default \{defaultN,defaultN-\})\@nil%
  \extractkey/zx/wires definition/-N'=-andL config (default \{defaultN,defaultN-\})\@nil%
  \extractkey/zx/wires definition/-N.=-andL config (default \{defaultN,defaultN-\})\@nil%
  \extractkey/zx/wires definition/N-=-andL config (default \{defaultN,defaultN-,symmetry\})\@nil%
  \extractkey/zx/wires definition/N'-=-andL config (default \{defaultN,defaultN-,symmetry\})\@nil%
  \extractkey/zx/wires definition/N.-=-andL config (default \{defaultN,defaultN-,symmetry\})\@nil%
  \extractkey/zx/wires definition/Nbase=-andL config (default defaultN)\@nil%
  \makeatother
  \pgfmanualbody
  |N| is used to create a left-to-right wire leaving at wide angle and arriving at wide angle (it's named |N| because it roughly have the shape of a capital |N|). In older versions, |'| and |.| was required to specify if the wire should go up-right or down-right, but it is not useful anymore (we keep it for compatibilty with |IO| styles and in case some styles want to do a distinction later).
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{\alpha} \ar[N,rd] \\
                               & \zxZ{\beta}\\
                               & \zxZ{\alpha}\\
    \zxX{\beta} \ar[N,ru]
  \end{ZX}
\end{codeexample}
|-| forces the angle on the side of |-| to be horizontal.
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{\alpha} \ar[-N,rd] \\
                               & \zxZ{\beta}\\
                               & \zxZ{\alpha}\\
    \zxX{\beta} \ar[N-,ru]
  \end{ZX}
\end{codeexample}
Like other wires, it can be configured using |-| (horizontal relative position of anchor points) and |L| (vertical relative position of anchor points, make sure to have |-|$<$|L| to have a |N|-looking shape), |al={angle}{relative length}|\dots{}
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{\alpha} \ar[N,rd] \\
                               & \zxZ{\beta}\\
    \zxX{\alpha} \ar[N={L=1.2},rd] \\
                               & \zxZ{\beta}
  \end{ZX}
\end{codeexample}
All these styles are based on Nbase (which should not be used directly), including the styles like |<|. If you wish to overwrite later |N|-like commands, but not |<|-like, then change |N|. If you wish to also update |<| commands, use |Nbase|.
\end{pgfmanualentry}



\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/NN=-andL config (default \{defaultN,symmetry-L,defaultNN\})\@nil%
  \extractkey/zx/wires definition/NN.=-andL config (default \{defaultN,symmetry-L,defaultNN\})\@nil%
  \extractkey/zx/wires definition/.NN=-andL config (default \{defaultN,symmetry-L,defaultNN\})\@nil%
  \extractkey/zx/wires definition/NIN=-andL config (default \{defaultN,symmetry-L,defaultNN,defaultNIN\})\@nil%
  \extractkey/zx/wires definition/INN=-andL config (default \{defaultN,symmetry-L,defaultNN,defaultNIN,symmetry\})\@nil%
  \extractkey/zx/wires definition/NNI=-andL config (default \{defaultN,symmetry-L,defaultNN,defaultNIN,symmetry\})\@nil%
  \makeatother
  \pgfmanualbody
  Like |N| but for diagrams read up-to-down or down-to-up. The |.| are maintly used for backward compatibility with |IO| style.
% \begin{codeexample}[width=3cm]
%   \begin{ZX}
%     \zxX{\alpha} \ar[NN,rd] \\
%                                & \zxZ{\beta}\\
%                                & \zxZ{\alpha}\\
%     \zxX{\beta} \ar[NN,ru]
%   \end{ZX}
% \end{codeexample}
% |I| forces the angle on the side of |I| to be vertical.
% \begin{codeexample}[width=3cm]
%   \begin{ZX}
%     \zxX{\alpha} \ar[NIN,rd] \\
%                                & \zxZ{\beta}\\
%                                & \zxZ{\alpha}\\
%     \zxX{\beta} \ar[NNI,ru]
%   \end{ZX}
% \end{codeexample}
% It can be configured like |N| using |-|, |L|\dots{}
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/<'=-andL config (default like N-)\@nil%
  \extractkey/zx/wires definition/<.=-andL config (default like N-)\@nil%
  \extractkey/zx/wires definition/'>=-andL config (default like -N)\@nil%
  \extractkey/zx/wires definition/.>=-andL config (default like -N)\@nil%
  %\extractkey/zx/wires definition/^.=-andL config (default 60)\@nil%
  %\extractkey/zx/wires definition/.^=-andL config (default 60)\@nil%
  \extractkey/zx/wires definition/'v=-andL config (default like INN)\@nil%
  \extractkey/zx/wires definition/v'=-andL config (default like NNI)\@nil%
  \makeatother
  \pgfmanualbody
  |<'| and |<.| are similar to |N-|, except that the anchor of the vertical line is put on the boundary (similarly for |*>| and |-N|, |*v*| and |INN|, and |*^*| and |NIN|: |.^| and |^.| were not possible to put in this documentation since the documentation package does not like the |^| character). The position of |'| and |.| does not really matters anymore in new versions, but for backward compatibility with |IO| styles, and maybe forward compatibility (another style may need this information), it's cleaner to put |.| or |'| on the direction of the wire. It also helps the reader of your diagrams to see the shape of the wire.
\begin{codeexample}[width=0cm]
\begin{ZX}
  \zxN{}                         & \zxZ{}\\
  \zxX{} \ar[ru,<'] \ar[rd,<.] \\
  \zxN{}                         & \zxZ{}\\
\end{ZX}
\end{codeexample}
\begin{codeexample}[width=0cm]
\begin{ZX}
  \zxN{}                         & \zxZ{}\\
  \zxX{} \ar[ru,.>] \ar[rd,'>] \\
  \zxN{}                         & \zxZ{}\\
\end{ZX}
\end{codeexample}
\begin{codeexample}[width=0cm]
\begin{ZX}
  \zxN{} & \zxFracX{\pi}{2} \ar[dl,.^] \ar[dr,^.] & \\
  \zxZ{} &                                & \zxX{}
\end{ZX}
\end{codeexample}
\begin{codeexample}[width=0cm]
\begin{ZX}
  \zxZ{} &                                & \zxX{}\\
  \zxN{} & \zxX{} \ar[ul,'v] \ar[ur,v'] &
\end{ZX}
\end{codeexample}
\end{pgfmanualentry}


\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/3 dots=text (default =)\@nil%
  \extractkey/zx/wires definition/3 vdots=text (default =)\@nil%
  \makeatother
  \pgfmanualbody
  The styles put in the middle of the wire (without drawing the wire) $\dots$ (for |3 dots|) or $\vdots$ (for |3 vdots|). The dots are scaled according to |\zxScaleDots| and the text \meta{text} is written on the left. Use |&[\zxDotsRow]| and |\\[\zxDotsRow]| to properly adapt the spacing of columns and rows.
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxZ{\alpha} \ar[r,o'] \ar[r,o.]
               \ar[r,3 dots]
               \ar[d,3 vdots={$n$\,}] &[\zxDotsCol] \zxFracX{\pi}{2}\\[\zxDotsRow]
  \zxZ{\alpha} \rar             & \zxFracX{\pi}{2}
\end{ZX}
\end{codeexample}
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/H=style (default {})\@nil%
  \extractkey/zx/wires definition/Z=style (default {})\@nil%
  \extractkey/zx/wires definition/X=style (default {})\@nil%
  \makeatother
  \pgfmanualbody
  Adds a |H| (Hadamard), |Z| or |X| node (without phase) in the middle of the wire. Width of column or rows should be adapted accordingly using |\zxNameRowcolFlatnot| where |Name| is replaced by |H|, |S| (for ``spiders'', i.e.\ |X| or |Z|), |HS| (for both |H| and |S|) or |W|, |Rowcol| is either |Row| (for changing row sep) or |Col| (for changing column sep) and |Flatnot| is empty or |Flat| (if the wire is supposed to be a straight line as it requires more space). For instance:
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxZ{\alpha} \ar[d] \ar[r,o',H] \ar[r,o.,H] &[\zxHCol] \zxX{\beta}\\
  \zxZ{\alpha}  \ar[d,-o,X] \ar[d,o-,Z]                        \\[\zxHSRow]
  \zxX{\gamma}
\end{ZX}
\end{codeexample}
The \meta{style} parameter can be used to add additional \tikzname{} style to the nodes, notably a position using |\ar[rd,-N.,H={pos=.35}]|. The reason for using that is that the wires start inside the nodes, therefore the ``middle'' of the wire is closer to the node when the other side is on an empty node.
\begin{codeexample}[width=0pt]
\begin{ZX}[zx row sep=0pt]
 \zxN{} \ar[rd,-N.,H={pos=.35}] &[\zxwCol,\zxHCol]  &[\zxwCol,\zxHCol] \zxN{} \\[\zxNRow]%%
                                & \zxX{\alpha}
                                     \ar[ru,N'-,H={pos=1-.35}]
                                     \ar[rd,N.-,H={pos=1-.35}] &  \\[\zxNRow]
 \zxN{} \ar[ru,-N',H={pos=.35}]                                &  & \zxN{}
\end{ZX}
\end{codeexample}
Note that it's possible to automatically start wires on the border of the node, but it is slower and create other issues, see \cref{subsec:wiresInsideOutside} for more details. The second option (also presented in this section) is to manually define the |start anchor| and |end anchor|, but it can change the shape of the wire).
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/wire centered\@nil%
  \extractkey/zx/wires definition/wc\@nil%
  \extractkey/zx/wires definition/wire centered start\@nil%
  \extractkey/zx/wires definition/wcs\@nil%
  \extractkey/zx/wires definition/wire centered end\@nil%
  \extractkey/zx/wires definition/wce\@nil%
  \makeatother
  \pgfmanualbody
  Forces the wires to start at the center of the node (|wire centered start|, alias |wcs|), to end at the center of the node (|wire centered end|, alias |wce|) or both (|wire centered|, alias |wc|). This may be useful, for instance in the old |IO| mode (see below) when nodes have different sizes (the result looks strange otherwise), or with some wires (like |C|) connected to |\ZxNone+| (if possible, use |\zxNone| (without any embellishment) since it does not suffer from this issue as it is a coordinate).

  See also |between none| to also increase looseness when connecting only wires (use |between none| \emph{only} in |IO| mode).
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxZ{} \ar[IO,o',r] \ar[IO,o.,r]       & \zxX{\alpha}\\
  \zxZ{} \ar[IO,o',r,wc] \ar[IO,o.,r,wc] & \zxX{\alpha}
\end{ZX}
\end{codeexample}
% Without |wc| (note that because there is no node, we need to use |&[\zxWCol]| (for columns) and |\\[\zxWRow]| (for rows) to get nicer spacing):
% \begin{codeexample}[width=3cm]
% \zx{\zxNone{} \rar &[\zxWCol] \zxNone{} \rar &[\zxWCol] \zxNone{} }
% \end{codeexample}
% With |wc|:
% \begin{codeexample}[width=3cm]
% \zx{\zxNone{} \rar[wc] &[\zxWCol] \zxNone{} \rar[wc] &[\zxWCol] \zxNone{}}
% \end{codeexample}
\end{pgfmanualentry}


\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/bezier=-andL config \@nil%
  \extractkey/zx/wires definition/bezier x=-andL config \@nil%
  \extractkey/zx/wires definition/bezier y=-andL config \@nil%
  \extractkey/zx/wires definition/bezier 4=\{x1\}\{y1\}\{x2\}\{y2\} \@nil%
  \extractkey/zx/wires definition/bezier 4 x=\{x1\}\{y1\}\{x2\}\{y2\} \@nil%
  \extractkey/zx/wires definition/bezier 4 y=\{x1\}\{y1\}\{x2\}\{y2\} \@nil%
  \makeatother
  \pgfmanualbody
  To create a bezier wire. These styles are not really meant to be used for the final user because they are long to type and would not be changed document-wise when the style is changed, but most styles are based on these styles. For the |bezier 4 *| versions, the two first arguments are the relative position of the first anchor (|x| and |y| position), the next two of the second anchor. In the |bezier *| versions, the value of |1-| will be the relative |x| position of the first point, |1L| the relative position of the second, and |2-| and |2L| will be for the second point (the advantage of this is that it is also possible to specify angles using |1al={angle}{length}|\dots{} as explained in the |-andL| syle). They are said to be relative in the sense that |{0}{0}| is the coordinate of the first point, and |{1}{1}| the second point. The |bezier x| and |bezier 4 y| are useful when the node are supposed to be horizontally or vertically aligned: the distance are now expressed as a fraction of the horizontal (respectively vertical) distance between the two nodes. Using relative coordinates has the advantage that if the nodes positions are moved, the aspect of the wire does not change (it is just squeezed), while this is not true with |in|/|out| wires which preserves angles but not shapes.
\end{pgfmanualentry}


\subsubsection{IO wires, the old styles}\label{subsub:IOwires}

\begin{stylekey}{/zx/wires definition/IO}
As explained above, wires were first defined using |in|, |out| and |looseness|, but this turned out to be sometimes hard to use since the shape of the wire was changing depending on the position. For example consider the differences between the older version:
\begin{codeexample}[]
\begin{ZX}
  \zxN{}                       & \zxZ{} \\
  \zxZ{} \ar[ru,IO,N'] \ar[rd,IO,N.] &\\
                               & \zxZ{} \\
\end{ZX}
\begin{ZX}
  \zxN{}                       & \zxZ{} \\[-3pt]
  \zxZ{} \ar[ru,IO,N'] \ar[rd,IO,N.] &\\[-3pt]
                               & \zxZ{} \\
\end{ZX}
\begin{ZX}
  \zxN{}                       & \zxZ{} \\[-5pt]
  \zxZ{} \ar[ru,IO,N'] \ar[rd,IO,N.] &\\[-5pt]
                               & \zxZ{} \\
\end{ZX}
\end{codeexample}
\begin{codeexample}[]
\begin{ZX}
  \zxN{}                       & \zxZ{} \\
  \zxZ{} \ar[ru,N'] \ar[rd,N.] &\\
                               & \zxZ{} \\
\end{ZX}
and the newer:
\begin{ZX}
  \zxN{}                       & \zxZ{} \\[-3pt]
  \zxZ{} \ar[ru,N'] \ar[rd,N.] &\\[-3pt]
                               & \zxZ{} \\
\end{ZX}
\begin{ZX}
  \zxN{}                       & \zxZ{} \\[-5pt]
  \zxZ{} \ar[ru,N'] \ar[rd,N.] &\\[-5pt]
                               & \zxZ{} \\
\end{ZX}
\end{codeexample}
Here is another example:
\begin{codeexample}[]
Before \begin{ZX}
  \zxNone{} \ar[IO,C,d,wc] \ar[rd,IO,s] &[\zxWCol] \zxNone{} \\[\zxWRow]
  \zxNone{}                \ar[ru,IO,s] &          \zxNone{}
\end{ZX} after \begin{ZX}
  \zxNone{} \ar[C,d] \ar[rd,s] &[\zxWCol] \zxNone{} \\[\zxWRow]
  \zxNone{}          \ar[ru,s] &          \zxNone{}
\end{ZX}
\end{codeexample}
This example led to the creation of the |bn| style, in order to try to find appropriate looseness values depending on the case\dots{} but it is harder to use and results are less predictable.

The new method also allowed us to use |N| for both |N.| and |N'| styles (however we kept both versions for backward compatibility and in case later we want to make a distinction between nodes going doing or up).

However, if you prefer the old style, you can just use them by adding |IO,| in front of the style name (styles are nested inside |IO|). Note however that the customization options are of course different.
\end{stylekey}

We list now the older |IO| styles:

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/IO/C\@nil%
  \extractkey/zx/wires definition/IO/C\@nil%
  \extractkey/zx/wires definition/IO/C'\@nil%
  \extractkey/zx/wires definition/IO/C-\@nil%
  \makeatother
  \pgfmanualbody
  |IO| mode for the |C| wire (used for Bell-like shapes).
\begin{codeexample}[]
  Bell pair \zx{\zxNone{} \ar[d,IO,C] \\[\zxWRow]
                \zxNone{}}
  and funny graph
  \begin{ZX}
    \zxX{} \ar[d,IO,C] \ar[r,C']  & \zxZ{} \ar[d,IO,C-]\\
    \zxZ{} \ar[r,IO,C.]           & \zxX{}
  \end{ZX}.
\end{codeexample}
Note that the |IO| version cannot really be used when nodes are not aligned (using |wc| can sometimes help with the alignment):
\begin{codeexample}[]
  Normal \begin{ZX}
    \zxX{\alpha} \ar[dr,C]\\
    & \zxNone{}
  \end{ZX}, and IO \begin{ZX}
    \zxX{\alpha} \ar[dr,IO,C]\\
    & \zxNone{}
  \end{ZX}
\end{codeexample}
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/IO/o'=angle (default 40)\@nil%
  \extractkey/zx/wires definition/IO/o.=angle (default 40)\@nil%
  \extractkey/zx/wires definition/IO/o-=angle (default 40)\@nil%
  \extractkey/zx/wires definition/IO/-o=angle (default 40)\@nil%
  \makeatother
  \pgfmanualbody
  |IO| version of |o|. Curved wire, similar to |C| but with a soften angle (optionally specified via \meta{angle}, and globally editable with |\zxDefaultLineWidth|). Again, the symbols specify which part of the circle (represented with |o|) must be kept.
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{} \ar[d,IO,-o] \ar[d,IO,o-]\\
    \zxZ{} \ar[r,IO,o'] \ar[r,IO,o.] & \zxX{}
  \end{ZX}.
\end{codeexample}
 Note that these wires can be combined with |H|, |X| or |Z|, in that case one should use appropriate column and row spacing as explained in their documentation:
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{\alpha} \ar[d,IO,-o,H] \ar[d,IO,o-,H]\\[\zxHRow]
    \zxZ{\beta} \rar & \zxZ{} \ar[r,IO,o',X] \ar[r,IO,o.,Z] &[\zxSCol] \zxX{}
  \end{ZX}.
\end{codeexample}
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/IO/(=angle (default 30)\@nil%
  \extractkey/zx/wires definition/IO/)=angle (default 30)\@nil%
  \extractkey/zx/wires definition/IO/('=angle (default 30)\@nil%
  \extractkey/zx/wires definition/IO/('=angle (default 30)\@nil%
  \makeatother
  \pgfmanualbody
  |IO| version of |(| (so far they are the same, but it may change later, use this version if you want to play with |looseness|). Curved wire, similar to |o| but can be used for diagonal items. The angle is, like in |bend right|, the opening angle from the line which links the two nodes. For the first two commands, the |(| and |)| symbols must be imagined as if the starting point was on top of the parens, and the ending point at the bottom.
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{} \ar[rd,IO,(] \ar[rd,IO,),red]\\
    & \zxZ{}
  \end{ZX}.
\end{codeexample}
Then, |('|=|(| and |(.|=|)|; this notation is, I think, more intuitive when linking nodes from left to right. |('| is used when going to top right and |(.| when going to bottom right.
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxN{}                       & \zxX{}\\
  \zxZ{} \ar[ru,IO,('] \ar[IO,rd,(.] & \\
                               & \zxX{}
\end{ZX}
\end{codeexample}
When the nodes are too far appart, the default angle of |30| may produce strange results as it will go above (for |('|) the vertical line. Either choose a shorter angle, or see |<'| instead.
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/IO/s\@nil%
  \extractkey/zx/wires definition/IO/s'=angle (default 30)\@nil%
  \extractkey/zx/wires definition/IO/s.=angle (default 30)\@nil%
  \extractkey/zx/wires definition/IO/-s'=angle (default 30)\@nil%
  \extractkey/zx/wires definition/IO/-s.=angle (default 30)\@nil%
  \extractkey/zx/wires definition/IO/s'-=angle (default 30)\@nil%
  \extractkey/zx/wires definition/IO/s.-=angle (default 30)\@nil%
  \makeatother
  \pgfmanualbody
  |IO| version of |s|. |s| is used to create a s-like wire, to have nicer soften diagonal lines between nodes. Other versions are soften versions (the input and output angles are not as sharp, and the difference angle can be configured as an argument or globally using |\zxDefaultSoftAngleS|). Adding |'| or |.| specifies if the wire is going up-right or down-right.
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{\alpha} \ar[IO,s,rd] \\
                               & \zxZ{\beta}\\
    \zxX{\alpha} \ar[IO,s.,rd] \\
                               & \zxZ{\beta}\\
                               & \zxZ{\alpha}\\
    \zxX{\beta} \ar[IO,s,ru] \\
                               & \zxZ{\alpha}\\
    \zxX{\beta} \ar[IO,s',ru] \\
  \end{ZX}
\end{codeexample}
|-| forces the angle on the side of |-| to be horizontal.
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{\alpha} \ar[IO,s.,rd] \\
                           & \zxZ{\beta}\\
    \zxX{\alpha} \ar[IO,-s.,rd] \\
                           & \zxZ{\beta}\\
    \zxX{\alpha} \ar[IO,s.-,rd] \\
                           & \zxZ{\beta}\\
  \end{ZX}
\end{codeexample}
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/IO/ss\@nil%
  \extractkey/zx/wires definition/IO/ss.=angle (default 30)\@nil%
  \extractkey/zx/wires definition/IO/.ss=angle (default 30)\@nil%
  \extractkey/zx/wires definition/IO/sIs.=angle (default 30)\@nil%
  \extractkey/zx/wires definition/IO/.sIs=angle (default 30)\@nil%
  \extractkey/zx/wires definition/IO/ss.I-=angle (default 30)\@nil%
  \extractkey/zx/wires definition/IO/I.ss-=angle (default 30)\@nil%
  \makeatother
  \pgfmanualbody
  |IO| version of |ss|. |ss| is similar to |s| except that we go from top to bottom instead of from left to right. The position of |.| says if the node is wire is going bottom right (|ss.|) or bottom left (|.ss|).
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{\alpha} \ar[IO,ss,rd] \\
                           & \zxZ{\beta}\\
    \zxX{\alpha} \ar[IO,ss.,rd] \\
                           & \zxZ{\beta}\\
                           & \zxX{\beta} \ar[IO,.ss,dl] \\
    \zxZ{\alpha}\\
                           & \zxX{\beta} \ar[IO,.ss,dl] \\
    \zxZ{\alpha}\\
  \end{ZX}
\end{codeexample}
|I| forces the angle above (if in between the two |s|) or below (if on the same side as |.|) to be vertical.
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{\alpha} \ar[IO,ss,rd] \\
                           & \zxZ{\beta}\\
    \zxX{\alpha} \ar[IO,sIs.,rd] \\
                           & \zxZ{\beta}\\
    \zxX{\alpha} \ar[IO,ss.I,rd] \\
                           & \zxZ{\beta}\\
                           & \zxX{\beta} \ar[IO,.sIs,dl] \\
    \zxZ{\alpha}\\
                           & \zxX{\beta} \ar[IO,I.ss,dl] \\
    \zxZ{\alpha}\\
  \end{ZX}
\end{codeexample}
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/IO/<'=angle (default 60)\@nil%
  \extractkey/zx/wires definition/IO/<.=angle (default 60)\@nil%
  \extractkey/zx/wires definition/IO/'>=angle (default 60)\@nil%
  \extractkey/zx/wires definition/IO/.>=angle (default 60)\@nil%
  %\extractkey/zx/wires definition/IO/^.=angle (default 60)\@nil%
  %\extractkey/zx/wires definition/IO/.^=angle (default 60)\@nil%
  \extractkey/zx/wires definition/IO/'v=angle (default 60)\@nil%
  \extractkey/zx/wires definition/IO/v'=angle (default 60)\@nil%
  \makeatother
  \pgfmanualbody
  These keys are a bit like |('| or |(.| but the arrival angle is vertical (or horizontal for the |^| (up-down) and |v| (down-up) versions). As before, the position of the decorator |.|,|'| denote the direction of the wire.
\begin{codeexample}[width=0cm]
\begin{ZX}
  \zxN{}                         & \zxZ{}\\
  \zxX{} \ar[IO,ru,<'] \ar[IO,rd,<.] \\
  \zxN{}                         & \zxZ{}\\
\end{ZX}
\end{codeexample}
\begin{codeexample}[width=0cm]
\begin{ZX}
  \zxN{} & \zxFracX{\pi}{2} \ar[IO,dl,.^] \ar[IO,dr,^.] & \\
  \zxZ{} &                                & \zxX{}
\end{ZX}
\end{codeexample}
\begin{codeexample}[width=0cm]
\begin{ZX}
  \zxZ{} &                                & \zxX{}\\
  \zxN{} & \zxX{} \ar[IO,ul,'v] \ar[IO,ur,v'] &
\end{ZX}
\end{codeexample}
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/IO/N'=angle (default 60)\@nil%
  \extractkey/zx/wires definition/IO/N.=angle (default 60)\@nil%
  \extractkey/zx/wires definition/IO/-N'=angle (default 60)\@nil%
  \extractkey/zx/wires definition/IO/-N.=angle (default 60)\@nil%
  \extractkey/zx/wires definition/IO/N'-=angle (default 60)\@nil%
  \extractkey/zx/wires definition/IO/N.-=angle (default 60)\@nil%
  \makeatother
  \pgfmanualbody
  |IO| version of |N|. |N| is used to create a wire leaving at wide angle and arriving at wide angle. Adding |'| or |.| specifies if the wire is going up-right or down-right.
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{\alpha} \ar[IO,N.,rd] \\
                               & \zxZ{\beta}\\
                               & \zxZ{\alpha}\\
    \zxX{\beta} \ar[IO,N',ru] \\
  \end{ZX}
\end{codeexample}
|-| forces the angle on the side of |-| to be horizontal.
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{\alpha} \ar[IO,-N.,rd] \\
                               & \zxZ{\beta}\\
                               & \zxZ{\alpha}\\
    \zxX{\beta} \ar[IO,N'-,ru] \\
  \end{ZX}
\end{codeexample}
\end{pgfmanualentry}

\begin{stylekey}{/zx/wires definition/ls=looseness}
  Shortcut for |looseness|, allows to quickly redefine looseness. Use with care (or redefine style directly), and \emph{do not use on styles that are not in |IO|}, since they don't use the |in|/|out| mechanism (only |(|-like styles use |in|/|out|\dots{} for now. In case you want to change looseness of |(|, prefer to use |IO,(| as it is guaranteed to be backward compatible). We may try later to give a key |looseness| for these styles, but it's not the case for now. For |IO| styles, you can also change yourself other values, like |in|, |out|\dots
\begin{codeexample}[]
\begin{ZX}
  \zxZ{} \ar[rd,s] \\
                   & \zxX{}\\
  \zxZ{} \ar[rd,IO,s] \\
                   & \zxX{}\\
  \zxZ{} \ar[rd,IO,s,ls=3] \\
                   & \zxX{}
\end{ZX}
\end{codeexample}
\end{stylekey}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/between none\@nil%
  \extractkey/zx/wires definition/bn\@nil%
  \makeatother
  \pgfmanualbody
  When drawing only |IO| wires (normal wires would suffer from this parameter), the default looseness may not be good looking and holes may appear in the line. This style (whose alias is |bn|) should therefore be used when curved wires \emph{from the |IO| path} are connected together. In that case, also make sure to separate columns using |&[\zxWCol]| and rows using |\\[\zxWRow]|.
\begin{codeexample}[width=3cm]
A swapped Bell pair is %
\begin{ZX}
  \zxNone{} \ar[IO,C,d,wc] \ar[rd,IO,s,bn] &[\zxWCol] \zxNone{} \\[\zxWRow]
  \zxNone{}                \ar[ru,IO,s,bn] &          \zxNone{}
\end{ZX}
\end{codeexample}
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/bold\@nil%
  \extractkey/zx/wires definition/B\@nil%
  \extractkey/zx/wires definition/non bold\@nil%
  \extractkey/zx/wires definition/NB\@nil%
  \extractkey/zx/wires definition/boldn\@nil%
  \extractkey/zx/wires definition/boldn-\@nil%
  \extractkey/zx/wires definition/boldn'\@nil%
  \extractkey/zx/wires definition/boldn.\@nil%
  \extractkey/zx/wires definition/Bn=message (default n)\@nil%
  \extractkey/zx/wires definition/Bn-=message (default n)\@nil%
  \extractkey/zx/wires definition/Bn'=message (default n)\@nil%
  \extractkey/zx/wires definition/Bn.=message (default n)\@nil%
  \extractkey/zx/wires definition/BnArgs=\{message\}\{style\} (default \{n\}\{\})\@nil%
  \extractkey/zx/wires definition/Bn-Args=\{message\}\{style\} (default \{n\}\{\})\@nil%
  \extractkey/zx/wires definition/Bn'Args=\{message\}\{style\} (default \{n\}\{\})\@nil%
  \extractkey/zx/wires definition/Bn.Args=\{message\}\{style\} (default \{n\}\{\})\@nil%
  \makeatother
  \pgfmanualbody
  Creates a bold (or non-bold) wire (|B| and |NB| being short aliases). The versions with a |n| at the end adds a $n$ on the right/left/above/below (for the respective symbols empty, |-|, |'|, |.|), that you can overwrite by providing an option:
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
\begin{ZX}
  \zxX[bold]{} \rar[Bn,o'] \rar[Bn.=m,o.] &[\zxwCol] \zxZ{} \rar &[\zxwCol] \zxN{}
\end{ZX}
\end{codeexample}
}
Finally, the last variations with args like |BnArgs| allows you to provide an additional label style, notably arguments like |pos=.7| to change the position of the line in the path (when the lines are drawn from the middle of the nodes, which is the case for many styles by default for efficiency reasons, the middle of the path may appear poorly centered: using |pos| is one method to center it back, see also \cref{subsec:wiresInsideOutside}).
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
\begin{ZX}
  \zxX[bold]{} \rar[<.,Bn.Args={n}{pos=.6},dr] &[\zxwCol] \\
                                               & \zxN{}
\end{ZX}
\end{codeexample}
}
\end{pgfmanualentry}


\subsection{Custom nodes}\label{subsec:customNodes}

\textbf{NB}: this functionality was added on 24/02/2023.

Technically, there is nothing preventing a user to create any style to create custom nodes like:
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
  \begin{ZX}
    \zxN{} \rar & |[draw,fill=blue!50,draw=blue,inner sep=3mm]| \text{my custom node}
  \end{ZX}
\end{codeexample}
}
possibly using |\tikzset| and/or |\NewExpandableDocumentCommand| to avoid repetitions:
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
  \tikzset{
    my custom node/.style={
      draw,fill=blue!50,draw=blue,inner sep=3mm
    },
  }
  \NewExpandableDocumentCommand{\myCustomNode}{m}{|[my custom node]| \text{#1}}
  \begin{ZX}
    \zxN{} \rar & \myCustomNode{Hey}
  \end{ZX}
\end{codeexample}
}
However, this method has several limitations: first, it is non-trivial to define complex shapes this way (you have a single node, so you need to use more advanced tikz primitives to make it right), it is even harder to create variations of this shape without repeating yourself (like different rotations of the same shape), and it is quite hard to define anchors to start/stop arrows like |\rar[<']| at the right position\footnote{In that case, the center of the shape will be used even if it might not be desirable}â¦ not even mentioning multiple anchors. We therefore provide below some helper functions.

\begin{pgfmanualentry}
  \def\extrakeytext{style, }
  \extractcommand\zxNewNodeFromPic\marg{name new node}\oarg{style before user}\oarg{style after user}\marg{code}\@@
  \makeatletter% should not be letter for \@@... strange
  \extractkey/tikz/zx create anchors=\marg{list, of, coordinates, to, turn, in, anchor}\@nil%
  \extractkey/tikz/invert top bottom\@nil%
  \extractkey/tikz/start subnode=\marg{name of subnode}\@nil%
  \extractkey/tikz/stop subnode=\marg{name of subnode}\@nil%
  \makeatother
  \pgfmanualbody
  |\zxNewNodeFromPic{Name}[style before][style after]{code}| is used to create a new command with name |\zxName|. |code| is the code to draw the node (that you would use in a |\pic| environment, and that will be centered on |(0,0)|):
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
  \zxNewNodeFromPic{MyNode}{
    \node[draw,fill=blue!50,draw=blue,inner sep=3mm, zx main node, alias=mynode] at (0,0) {};
    \node[draw,fill=red!50,draw=blue,inner sep=1mm] at (mynode.north east) {};
  }
  \begin{ZX}
    \zxN{} \rar & \zxMyNode{} \rar & \zxMyNode{}
  \end{ZX}
\end{codeexample}
}
Note how giving |zx main node| to a node makes it the target of arrows (note that you should make sure that your picture has at least one main node if you want features like |debug mode| to work). Without this, the lines would go to the coordinate |(0,0)|, and go through all the nodes:
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
  \zxNewNodeFromPic{MyNode}{
    \node[draw,fill=blue!50,draw=blue,inner sep=3mm, alias=mynode] at (0,0) {};
    \node[draw,fill=red!50,draw=blue,inner sep=1mm] at (mynode.north east) {};
  }
  \begin{ZX}
    \zxN{} \rar & \zxMyNode{}
  \end{ZX}
\end{codeexample}
}
Note that sometimes, one might want to draw lines to a fixed point, while leaving the line below the object (for instance if you use a |rounded corners| option and try to enter by the corner, tikz will actually stop before which is not beautiful). A simple solution is to use |wc| (short for |wire centered|) on the arrow, and it will automatically move the path on a layer behind (see also |wcs| and |wce| to configure only the starting or ending points, and some other nodes also use this, notably most styles based on |bezier|, like |s|):
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
\zxNewNodeFromPic{MyDivider}{
  \node[regular polygon, regular polygon sides=3, shape border rotate=90,
        draw=black,fill=gray!50, inner sep=1.6pt, rounded corners=0.8mm,zx main node] {};
}
Compare %
\begin{ZX}
  \zxZ{} \rar[very thick]  &\zxMyDivider{} \rar[very thick] & \zxN{}
\end{ZX} %
and %
\begin{ZX}
  \zxZ{} \rar[very thick,wce]  &\zxMyDivider{} \rar[very thick] & \zxN{} 
\end{ZX}
\end{codeexample}
}
Note that I'm working on a better solutions to move nodes on different layers, or automatically see which anchor to choose depending on the custom nodeâ¦ but it's not that \mylink{https://tex.stackexchange.com/questions/618823/node-on-layer-style-in-tikz-matrix-tikzcd}{easy}.

We can similarly put the |zx main node| on the other node to point to the other node by default:
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
  \zxNewNodeFromPic{MyNode}{
    \node[draw,fill=blue!50,draw=blue,inner sep=3mm, alias=mynode] at (0,0) {};
    \node[draw,fill=red!50,draw=blue,inner sep=1mm, zx main node] at (mynode.north east) {};
  }
  \begin{ZX}
    A \rar[end anchor=center,on layer=main] & \zxMyNode{} \rar & B & \zxMyNode{} & \zxMyNode{}
  \end{ZX}
\end{codeexample}
}

\paragraph{Add margin around nodes.} You might want to add empty paths to increase the ``margin'' around your picture, or |overlay| some nodes if you don't want them to be counted when computing the bounding box. For simplicity, we provide a command |\zxExtendBoundingBox| that extends the current bounding box. This command takes as argument a list of arguments like |left|, |right|, |top|, |bottom|, |horizontal|, |vertical|, |extend|, where each argument takes a distance and extends to the corresponding direction (|extend| extends in all directions). For instance, below we increase the box by 1cm horizontally and by 3mm on each side on the y axis:
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
  \zxNewNodeFromPic{MyNode}{
    \node[draw,fill=blue!50,draw=blue,inner sep=3mm, zx main node] at (0,0) {};
    \zxExtendBoundingBox{horizontal=1cm, vertical=3mm}
  }
  \begin{ZX}
    A \rar & \zxMyNode{} \rar & B\\
  \end{ZX}
\end{codeexample}
}

\paragraph{Give text as argument.} It is also possible to pass text as an argument by simply adding |\tikzpictext| where you want the text to appear, and calling then |\zxMyNode{your text}|:
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
  \zxNewNodeFromPic{MyNode}{
    \node[draw,fill=blue!50,draw=blue,inner sep=3mm, zx main node, alias=mynode] at (0,0) {\tikzpictext};
    \node[draw,fill=red!50,draw=blue,inner sep=1mm] at (mynode.north east) {};
  }
  \begin{ZX}
    \zxMyNode{Hello} & \zxMyNode{do you see} & \zxMyNode{the text} & ?
  \end{ZX}
\end{codeexample}
}

\paragraph{Pass arbitrary arguments.} You can actually pass virtually any argument(s) by using the optional argument of the created |\zxMyNode| (that is just an additional argument to the pic options, inserted before \emph{style after user}, but after \emph{style before user} that we can use to create additional arguments with default values using the tikz/pgf power):
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
% Requires \usetikzlibrary {shapes.geometric} for the star shape
\zxNewNodeFromPic{MyStar}[
  nb spikes/.store in=\myNbSides, % When users type nb spikes=42, this puts 42 into \myNbSides
  nb spikes=5, % <- Default value
]{
  \node[star, star points=\myNbSides, minimum size=6mm, draw, fill=red] at (0,0) {};
}
\begin{ZX}
  \text{Default:} & \zxMyStar{} & \text{More !} & \zxMyStar[nb spikes=8]{} & \zxMyStar[nb spikes=12]{}
\end{ZX}
\end{codeexample}
}

\paragraph{Overriding existing parameters.}

You might want to override a custom node, for instance because this custom node was provided by an external library (e.g.\ the ground and scalable ZX symbols are made using custom-nodes, and you might want to customize them). We provide for that a series of styles: if |XXXX| is the name on the node (e.g.\ |Ground|), the |/zx/picCustomStyleBeforeUserXXXX| style is sent to the picture style before loading the options of the user, |/zx/picCustomStyleAfterUserXXXX| is loaded after the input of the user, |/zx/picCustomStyleLastPicXXXX| is loaded as the last argument to the picture (after the default style). You can also set the command |\zxCustomPicAdditionalPic| to any code to draw at the end of the picture:
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
\tikzset{
  /zx/picCustomStyleBeforeUserMatrix/.style={
    scale=2,
    % \zxCustomPicAdditionalPic can be any tikz code to run after the creation of the pic:
    /utils/exec={\def\zxCustomPicAdditionalPic{%
        % the main node has empty name, so .center is the center of the main node
        \node[draw,circle,inner sep=2pt,fill=pink] at (.center) {};%
      }%
    },
  },
}
\begin{ZX}
  \zxZ{} \rar & \zxMatrix{A} \rar & \zxMatrix*{B} \rar & \zxN{}
\end{ZX}
\end{codeexample}
}

When designing your own custom nodes, you can also put:\\
|NameOfYourStyle/.append style={}, NameOfYourStyle,|\\
where you want to allow users to load |NameOfYourStyle| (|NameOfYourStyle/.append style={}| is used to create the style if it does not exist).

If you want to change a create a new node style without overriding a style, you can of course create your own command that sets the parameters for you:
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
\tikzset{
  /zx/picCustomStyleBeforeUserMatrix/.style={
    scale=2,
    % \zxCustomPicAdditionalPic can be any tikz code to run after the creation of the pic:
    /utils/exec={\def\zxCustomPicAdditionalPic{%
        % the main node has empty name, so .center is the center of the main node
        \node[draw,circle,inner sep=2pt,fill=pink] at (.center) {};%
      }%
    },
  },
}
\begin{ZX}
  \zxZ{} \rar & \zxMatrix{A} \rar & \zxMatrix*{B} \rar & \zxN{}
\end{ZX}
\end{codeexample}
}

\paragraph{Local style.}

Sometimes, you might want to define styles that are available only locally: for instance, you might prefer to type |main={fill=green}| instead of:\\
|/zx/picCustomStyleBoxMainNode/.append style={fill=green}|\\
Nothing prevents you from doing so directly in the default style. Just, make sure to use, e.g.\ |####1|, if you want to call an argument (internally we use nested styles and functions):

{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
\zxNewNodeFromPic{MyBox}[
  main/.style={
    /zx/picCustomStyleMyBoxMainNode/.append style={####1},
  },
]{%
  \node[draw, inner sep=1.3mm, rectangle, zx main node, execute at begin node=$, execute at end node=$,
    /zx/picCustomStyleMyBoxMainNode/.append style={}, % Make sure it exists to avoid errors
    /zx/picCustomStyleMyBoxMainNode,
  ]{\tikzpictext};%
}

\begin{ZX}
  \zxMyBox{G} \rar[B]                    & [\zxwCol] \zxN{}\\
  \zxMyBox[main={fill=green}]{G} \rar[B] & [\zxwCol] \zxN{}
\end{ZX}
\end{codeexample}
}

\paragraph{Rotations.} Note that often, we want to rotate the nodes. The automatically generated macro to add new nodes comes with multiple flavors by adding the usual symbols |-|,|'|,|'|: by default, |\myNode-| will ``rotate'' by 180 degrees the pic, |\myNode'| will rotate it by 270 degrees to fake a node put ``above'', and |\myNode'| will rotate it by 90 degrees to fake a node put below. Importantly, by default tikz rotates/scales the coordinates, but \textbf{not the nodes or text}, so you might want to specify \textbf{transform shape} on each node you want to rotate and scale according to the parent transform, or using the |every node/.append style={transform shape}| (\textbf{WARNING}: make sure to use |append| or otherwise |zx main node| you not work and you will not be able to give a name to a node) option to apply it on all nodes:
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
  \zxNewNodeFromPic{MyTriangle}[
    % To also rotate/scale the node, otherwise only it's coordinate is rotated
    every node/.append style={transform shape},
    % Just to show how to quickly scale a node by default, to quickly update the size of a whole picture:
    scale=1.3
  ]{
      \node[regular polygon, regular polygon sides=3, shape border rotate=90, draw=black,fill=blue!50, inner sep=1mm,rounded corners, zx main node] {};
  }
  \begin{ZX}
    \zxMyTriangle{} \rar & \zxMyTriangle-{} & \zxMyTriangle'{} \dar \\
                         &                  & \zxMyTriangle.{}
  \end{ZX}
\end{codeexample}
}
Note however that you can customize how rotations is applied. By default, the |'-.| variants updates |\zxCurrentRotationMode| to the rotation angle (from 0 to 90,180,270), and do |rotate=\zxCurrentRotationMode|. You can however easily change that behavior, by first undoing this rotation (in the \emph{style before user}) with |rotate=-\zxCurrentRotationMode| and do any action you like depending on the value of |\zxCurrentRotationMode|. Here is a nice use-case: if you rotate a node with |transform shape|, it will also rotate the text inside:
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
  \zxNewNodeFromPic{MyTriangle}[
    every node/.append style={transform shape},
  ]{
      \node[regular polygon, regular polygon sides=3, shape border rotate=90, draw=black,fill=blue!50, font=\footnotesize,inner sep=1pt,rounded corners, zx main node] {\tikzpictext};
  }
  \begin{ZX}
    \zxMyTriangle{A} \rar   & \zxMyTriangle-{A}   & \zxMyTriangle'{A} \dar   \\
                            &                     & \zxMyTriangle.{A}        \\
  \end{ZX}
\end{codeexample}
}
To avoid that issue, we will undo the default rotation, and apply on the node of interest a rotation with |shape border rotate| (that rotates the border but not the text inside):
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
  \zxNewNodeFromPic{MyTriangle}[
    % We undo the default rotation:
    rotate=-\zxCurrentRotationMode,
  ]{
    \node[
      regular polygon, regular polygon sides=3, draw=black,fill=blue!50, font=\footnotesize,
      inner sep=1pt,rounded corners, zx main node,
      shape border rotate=90+\zxCurrentRotationMode, % Rotates the shape but not the text
    ] {\tikzpictext};
  }
  \begin{ZX}
    \zxMyTriangle{A} \rar   & \zxMyTriangle-{A}   & \zxMyTriangle'{A} \dar   \\
                            &                     & \zxMyTriangle.{A}        \\
  \end{ZX}
\end{codeexample}
}
Note that one might want to exchange |\zxMyNode|/|\zxMyNode-| or |\zxMyNode'|/|\zxMyNode.| (for instance, it might be more natural to denote |'| in place of |.| and |.| in place |'|, since these symbols visually represent the top/bottom place of the node). In that case, you just need to apply the style |invert top bottom| or |invert right left| in your \emph{style before user} and it will invert them automatically.

\paragraph{Add anchors to node.} We can automatically (and easily) add multiple anchors to our nodes (the |fake center east/â¦| anchor is used for instance by shapes like |\ar[<']| to see where the node should start from): just add coordinates with the name of the desired anchor in your graph (say |anchorA| and |anchorB|), and in \emph{style \textbf{after} user} add this list of anchor like: |zx create anchors={anchorA,anchorB}| (actually this list is expanded using the |\foreach| syntax so you can use more advanced syntax like |anchor1,anchor...,anchor10| to avoid repeating the 10 names of the anchor). For instance, we can do this way:
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
  \zxNewNodeFromPic{MyStar}[][
    % Note that this is the SECOND optional argument!
    zx create anchors={anchorA,anchorB},
  ]{
      \node[star, minimum size=6mm, draw, alias=mystar, fill=red, zx main node] at (0,0) {};
      \coordinate (anchorA) at (mystar.outer point 1);
      \coordinate (anchorB) at (mystar.outer point 2);
  }
  \begin{ZX}
    A \rar \rar[->,end anchor=anchorA,bend left] \rar[->,end anchor=anchorB,bend left]  &[5mm] \zxMyStar{}
  \end{ZX}
\end{codeexample}
}
The ZX library typically uses four special anchors |fake center east/â¦| to determine where some wires should start (not all kinds of wires follow this convention). Because the north anchor is not anymore in the north after applying a rotation, we provide also |\zxVirtualCenterWest| (same for |East|, |North|, |South|) that will ``counter balance'' the rotation, to ensure the real north anchor is always in the north, by renaming the anchors appropriately. This way, by using these ``virtual anchors'', you only need to place your anchor when the shape is not rotated, and it should automatically rotate the anchors appropriately when needed (see remarks regarding |every node/.append style={transform shape}|):
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
% Define a reusable node
  \zxNewNodeFromPic{MyDivider}[][zx create anchors={\zxVirtualCenterWest, \zxVirtualCenterEast},
  every node/.append style={transform shape}
  ]{
  \node[regular polygon, regular polygon sides=3,shape border rotate=90,%shape border rotate=90,
        draw=black,fill=gray!50, inner sep=1.6pt, rounded corners=0.8mm,zx main node] {};
  \coordinate(\zxVirtualCenterEast) at (.2mm,0); % Used to start lines on the side of the shape
  \coordinate(\zxVirtualCenterWest) at (-1mm,0);
}
% Use the node horizontally
\begin{ZX}
  \zxZ[B]{} \rar[Bn'=n+m, wc] & \zxMyDivider{} 
                                  \rar[o',Bn'Args={n}{}]
                                  \rar[o.,Bn.Args={m}{}] &[\zxWCol] \zxMyDivider-{} \rar[B,wc] & \zxZ[B]{}
\end{ZX}
% Use the node vertically                         
\begin{ZX}
  \zxZ[B]{} \dar[Bn=n+m, wc] \\
  \zxMyDivider'{} \dar[-o,BnArgs={n}{}] \dar[o-,Bn-Args={m}{}] \\[\zxWRow]
  \zxMyDivider.{} \dar[B,wc]\\
  \zxZ[B]{}
\end{ZX}
\end{codeexample}
}

You can even dynamically add anchors depending on the input of the user. For instance, if the user can choose the number of spikes of the star, you might want to create as many anchors as there are spikes:
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
\zxNewNodeFromPic{MyStar}[
  nb spikes/.store in=\myNbSides,
  nb spikes=5,
  every node/.append style={transform shape},
  ][
    % zx create anchors is parsed ultimately by \foreach so we can use lists like
    % this to create anchors spike-1, spike-2...
    zx create anchors/.expanded={spike-1,spike-...,spike-\myNbSides},
  ]{%
    \node[star, fill=red, star points=\myNbSides, minimum size=1cm, draw, alias=mystar]
      at (0,0) {\tikzpictext};
    % We need to place coordinates where we want to final anchors to be.
    \foreach \i in {1,...,\myNbSides}{
      \coordinate (spike-\i) at (mystar.outer point \i);
    }%
}
\begin{ZX}
  B \foreach \i in {1,...,8}{\expanded{\noexpand\rar[->,end anchor=spike-\i,bend left]}}  &[5cm] \zxMyStar[nb spikes=8]{?!?}
\end{ZX}
\end{codeexample}
}

Note that this library uses some anchors called |fake center {east,west,north,south}|, to indicate for some curve style where the line should start and stop (|\ar| alone does not use any anchor, and not all curves use them: |S| for instance does not use it, while |s| does: in any case, you can force it for any curve with |force left to right| and alike, see the corresponding documentation Note also that in this mode the curve is drawn by default below the shapes, but this can be changed, see the corresponding section for details). 
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
\zxNewNodeFromPic{MyNode}[][zx create anchors/.expanded={fake center west}]{
  \node[draw,fill=blue!50,draw=blue,inner sep=3mm, zx main node, alias=mynode] at (0,0) {};
  \node[draw,fill=red!50,draw=blue,inner sep=1mm] at (mynode.north east) {};
  \coordinate(fake center west) at (mynode.north east);
}
\begin{ZX}
  \zxZ{} \ar[rd,s] & \\
  A \rar           & \zxMyNode{}  
\end{ZX}
\end{codeexample}
}

\paragraph{Link to a sub-node.} Sometimes, we might prefer to draw a link to a node instead of an anchor (an anchor can only be a single coordinate). To that end, just name your nodes as usual, and use |from subnode| or |to subnode| to do the link
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
  \zxNewNodeFromPic{MyDoubleNode}{
      \node[fill=blue!20, zx main node, inner sep=3mm] at (0,0) {};
      \node[circle,fill=red!70, inner sep=.8mm,name=redNode] at (0,1.5mm) {};
      \node[circle,fill=orange!70, inner sep=.8mm, name=orangeNode] at (0,-1.5mm) {};
  }
  \begin{ZX}
    A \rar[end subnode=redNode] \rar[end subnode=orangeNode] &[5mm] \zxMyDoubleNode{}\\
    B \ar[ru, end subnode=orangeNode]
  \end{ZX}
\end{codeexample}
}

\end{pgfmanualentry}

\subsection{Caching pictures via an externalization library}

The pictures built with this package can easily take maybe 0.5 seconds per picture to be built, which can easily add up to a long compilation time. Caching externalization can save you a lot of time: I went from a tiny draft taking 30 seconds to be built to a built time of 2.5 seconds.

\subsubsection{robust-externalize: recommended}

While \tikzname{} provides an external library, it has many drawbacks that make it unusable in practice. To solve that issue, I created my own library called \mylink{https://github.com/leo-colisson/robust-externalize}{\texttt{robust-externalize}}. It's still very young, but has been working really reliably in my tests.

To use it, first install |robust-externalize| by copy/pasting robust-externalize.sty in your project (unless your \LaTeX{} distribution already has it), and load it using something like that (you might want to change the template to add packages to use when compiling separately the images):
\begin{lstlisting}
\usepackage{robust-externalize}
\pgfkeys{
  /robExt/.cd,
  templateZX/.style={
    set subfolder={robustExternalize/}, % Images will be put in the robustExternalize/ folder
    defineTemplate={
      \documentclass{standalone}
      %% You can update this template to fit your needs: put here any package/definition your ZX diagrams will need
      %% (if you use \input{}, make sure to use \input{../} as it is compiled in a subfolder)
      \usepackage{amsmath}
      \usepackage{zx-calculus}
      \begin{document}%
      \robExtMainContent%
      \end{document}
    },
    dependencies={}, % Add here any file that must induce a recompilation of your file if it changes.
  },
}

%% We redefine the ZX environments to use instead 
\RenewDocumentEnvironment{ZX}{O{}O{}+b}{%
  \begin{robExtern}{templateZX,#2}%
    \begin{ZX}[#1]%
      #3%
    \end{ZX}%
  \end{robExtern}%
}{}

\RenewDocumentCommand{\zx}{O{}O{}m}{%
  \begin{robExtern}{templateZX,#2}%
    \zx[#1]{#3}%
  \end{robExtern}%
}
\end{lstlisting}

Now, just recompile your project: it should cache the pictures. See \mylink{https://github.com/leo-colisson/robust-externalize}{\texttt{robust-externalize}} for more details.

\subsubsection{Tikz external: not recommended}

\textbf{WARNING}: I added some options to use tikz |external| library to save compilation time... And then I realized that tikz |external| was quite close to be unusable in practice as it has many caveats. I ended up coding my own replacement to externalize any operation, and it works much better! See comment in the previous section.

Since 2022/02/08, it is possible to use the tikz |external| library to save compilation time. To load it, you need to add the following tikz libraries:
\begin{verse}
  |\usetikzlibrary{external}|\\
  |\usetikzlibrary{zx-calculus}|\\
  |\tikzexternalize|\\
  |\zxConfigureExternalSystemCallAuto|\\
\end{verse}
Then, compile with shell-escape, for instance using |pdflatex -shell-escape yourfile.tex|.

\textbf{WARNING}: if |external| is loaded before |zx-calculus|, you don't need to run |\zxConfigureExternalSystemCallAuto|. This command is only useful to ensure the system call used by |external| displays errors appropriately by configuring the interaction mode to match the one used by the parent compilation command. If you prefer to disable this feature to use |external|'s default, define `\def\zxDoNotPatchSystemCall{}` before loading the |zx-calculus| library.

\alertwarning{Note however that this has not yet being extensively tested, and the \texttt{external} library has a few caveats presented below}
\begin{itemize}
\item If you change the order of the diagrams, or add a diagram in the middle of the document, all subsequent diagrams will be recompiled. This issue has been reported \mylink{https://github.com/pgf-tikz/pgf/issues/758}{here} and is caused by the fact that the figures are called \texttt{figure0},\dots,\texttt{figureN}. To limit this issue, you can regularly insert \texttt{\textbackslash{}tikzsetfigurename\{nameprefix\}} in your document with different names to avoid a full recompilation of the file (or using groups to change it for a single newly added equation).
\item The \texttt{external} library uses the main file to recompile each picture, so if your file is large or loads a lot of libraries, it may \mylink{https://tex.stackexchange.com/questions/633175/tikz-externalize-is-much-slower-than-tikz-on-first-run}{take a while to compile a single diagram} (to give an example, this library takes 41 seconds to compile without the externalize library, with the externalize library it takes 14mn for the first run and 3 seconds for the next runs). For this reason, you may want to use \texttt{\textbackslash{}tikzset\{external/export=false\}} or |\tikzexternaldisable| (the latter won't fail if your elements are not parsable by tikz external) in a group to disable temporarily the external library while you are writing your diagram. You may like the |list and make| option of tikz external that produces a Makefile that one can compile separately to build in parallel all pictures.
\item If you compile once a diagram without any error, and recompile it after inserting an error, you will see an error while compiling. But if you recompile again, the error will disappear and the diagram that lastly succeeded to build will be inserted instead of the newly buggy diagram. This has been reported \mylink{https://github.com/pgf-tikz/pgf/issues/1137}{here}.
\item Sometimes, |external| cuts some parts of the picture, namely when parts are drawn outside of the bounding box. I've not experienced that with zx diagrams directly (we don't go beyond the bounding box), but the example at the end of this document with the |double copy shadow| has such issues because the shadow is drawn outside of the bounding box. One should therefore disable the externalization (or increase the bounding box) in these cases.
\item It seems that sometimes the inner sep of some labels in |external| mode defaults to zero (see the CNOT example below), I'm not sure why. Adding explicitly the value of the label fixes this.
\end{itemize}

\begin{pgfmanualentry}
  \extractcommand\zxExternalAuto\@@
  \extractcommand\zxExternalWrap\@@
  \extractcommand\zxExternalNoWrap\@@
  \extractcommand\zxExternalNoWrapNoExt\@@
  \extractcommand\zxExternalWrapForceExt\@@
  \pgfmanualbody
  Also, the library |external| forces us to wrap our diagrams into a basically empty tikz-pictures to make it work. The current library will automatically wrap the diagrams when the |external| library is enabled, but you can customize how diagrams are wrapped manually: |\zxExternalAuto| (default) will wrap it automatically if |external| is enabled, |\zxExternalWrap| will always wrap it, |\zxExternalNoWrap| will never wrap it (you will get errors if you use |external|), |\zxExternalNoWrapNoExt| will not wrap the figure, but will disable temporary the externalization for diagrams to avoid errors and |\zxExternalWrapForceExt| will wrap the figures and enable tikz |external| locally only for zx-diagrams (using |\tikzexternalenable|). This last option is particularly useful when using |external| while most other environments are not compatible with externalization (like tikzcd, quantikz, blochsphere, maybe cryptocode\dots{}): the idea is to disable tikzexternalize everywhere, except for zx diagrams:
\begin{verse}
|\tikzexternalize|\\
|\tikzexternaldisable|\\
|\zxExternalWrapForceExt|
\end{verse}
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \extractcommand\zxExternalSuffix\marg{suffix}\@@
  \pgfmanualbody
By default, the library adds a suffix |zx| to figures corresponding to zx diagrams (it avoids to recompile diagrams when a normal figure is added in between two zx diagrams). You can change (or remove) this suffix using |\zxExternalSuffix{yoursuffix}|, where the suffix can also be empty.
\end{pgfmanualentry}

Note that if you get an error:\\
|Argument of \tikzexternal@laTeX@collect@until@end@tikzpicture has an extra }|\\
it is likely that you have an element that is not handled by tikz external, like a raw |tikzcd| environment, a |blochsphere| environment\dots{} Either disable temporary tikz external around it:\\
|{\tikzexternaldisable your code not compatible with external}|\\
or wrap your element around |\begin{tikzpicture}\node{your figure};\end{tikzpicture}| (people usually don't like nested tikz pictures\dots{} but it often works nicely). In case you also care about the baseline, you may prefer to wrap it using:\\
|\begin{tikzpicture}[baseline=(mynode.base)]\node(mynode){your figure};\end{tikzpicture}|

\subsection{How to visually group multiple nodes}\label{subsec:decoration}

\begin{pgfmanualentry}
  \def\extrakeytext{style, }
  \extractcommand\zxNamedBox\oarg{style}\oarg{color}\marg{nodes to fit}\oarg{label style}\marg{Text of label}\@@
  \pgfmanualbody
  This command is used to highlight a part of a diagram, like:
\begin{codeexample}[width=0cm]
  \begin{ZX}[
    execute at end picture={
      \zxNamedBox{(cnot1)(cnot2)}{
        below:\textsc{cnot}
      }
    }
    ]
    \zxN{} \rar &[\zxwCol] \zxZ[alias=cnot1]{} \dar \rar &[\zxwCol] \zxN{}\\
    \zxN{} \rar & \zxX[alias=cnot2]{} \rar      &[\zxwCol] \zxN{}\\
  \end{ZX}
\end{codeexample}

Note that the |fit| library cannot fit a wire. So if you want to include the wires around a node, the simpler thing might be to manually increase the size of the box in the style. We provide for that an helper command |fit margins={top=1mm,bottom=2mm,right=2.2mm,left=2.2mm}| (the |inner sep| and |shift| commands of tikz are not really practical to move a single border).
\begin{codeexample}[width=0cm]
  \begin{ZX}[
    execute at end picture={
      \zxNamedBox[fit margins={right=2.2mm}]{(measX)(measZ)}{
        below:\footnotesize Bell measurement
      }
      \zxNamedBox[fit margins={bottom=2pt,top=2pt,left=2.0mm}][green!80!black]{(bellA)(bellB)}{
        left:\footnotesize Bell pair:
      }
    }
    ]
    \zxN[a=bellA]{} \rar \dar[C] & [\zxwCol] \zxX*{x\pi} \rar   & \zxZ*{z\pi} \rar & \zxN{} \\[\zxwCol]
    \zxN[a=bellB]{} \rar         & \zxX[a=measX]{x\pi} \dar[C-] &                           \\
    \zxN{} \rar                  & \zxZ[a=measZ]{z\pi}
  \end{ZX}
\end{codeexample}
\end{pgfmanualentry}

\section{Advanced styling}

\subsection{Overlaying or creating styles}

It is possible to arbitrarily customize the styling, create or update ZX or tikz styles\dots{} First, any option that can be given to a |tikz-cd| matrix can also be given to a |ZX| environment (we refer to the manual of |tikz-cd| for more details). We also provide overlays to quickly modify the ZX style.

\begin{stylekey}{/zx/default style nodes}
  This is where the default style must be loaded. By default, it simply loads the (nested) style packed with this library, |/zx/styles/rounded style|. You can change the style here if you would like to globally change a style.

  Note that a style must typically define at least |zxZ4|, |zxX4|, |zxFracZ6|, |zxFracX6|, |\zxH|, |zxHSmall|, |zxNoPhaseSmallZ|, |zxNoPhaseSmallX|, |zxNone{,+,-,I}|, |zxNoneDouble{,+,-,I}| and all the |phase in label*|, |pil*| styles (see code on how to define them). Because the above styles (notably |zxZ*| and |zxFrac*|) are slightly complex to define (this is needed in order to implement |phase in label|, |-| versions\dots{}), it may be quite long to implement them all properly by yourself.

  For that reason, it may be easier to load our default style and overlay only some of the styles we use (see example in |/zx/user overlay nodes| right after). You can check our code in |/zx/styles/rounded style| to see what you can redefine (intuitively, the styles like |my style name| should be callable by the end user, |myStyleName| may be redefined by users or used in tikzit, and |my@style@name| are styles that should not be touched by the user). The styles that have most interests are |zxNoPhase| (for Z and X nodes without any phase inside), |zxShort| (for Z and X nodes for fractions typically), |zxLong| (for other Z and X nodes) and |stylePhaseInLabel| (for labels when using |phase in label|). These basic styles are extended to add colors (just add |Z|/|X| after the name) like |zxNoPhaseZ|\dots{} You can change them, but if you just want to change the color, prefer to redefine |colorZxZ|/|colorZxZ| instead (note that this color does not change |stylePhaseInLabelZ/X|, so you are free to redefine these styles as well). All the above styles can however be called from inside a tikzit style, if you want to use tikzit internally (make sure to load this library then in |*.tikzdefs|).

  Note however that you should avoid to call these styles from inside |\zx{...}| since |\zx*| and |\zxFrac*| are supposed to choose automatically the good style for you depending on the mode (fractions, labels in phase\dots{}). For more details, we encourage the advanced users too look at the code of the library, and examples for simple changes will be presented now.
\end{stylekey}

\begin{stylekey}{/zx/user overlay nodes}
  If a user just wants to overlay some parts of the node styles, add your changes here.
\begin{codeexample}[]
  {\tikzset{
      /zx/user overlay nodes/.style={
        zxH/.append style={dashed,inner sep=2mm}
      }}
    \zx{\zxNone{} \rar & \zxH{} \rar & \zxNone{}}
  }
\end{codeexample}
You can also change it on a per-diagram basis:
\begin{codeexample}[]
  \zx[text=yellow,/zx/user overlay nodes/.style={
    zxSpiders/.append style={thick,draw=purple}}
  ]{\zxX{} \rar & \zxX{\alpha} \rar & \zxFracZ-{\pi}{2}}
\end{codeexample}
The list of keys that can be changed will be given below in |/zx/styles/rounded style/*|.
\end{stylekey}

\begin{stylekey}{/zx/user overlay}
  This key will be loaded like it if were inside the options of the picture |\zx[options]{...}|. To avoid always typing |\zx[content vertically centered]{...}|, you can therefore use:
\begin{codeexample}[width=0pt]
\tikzset{
  /zx/user overlay/.style={
    content vertically centered,
  },
}
\begin{ZX}
  \zxX{\alpha} & \zxX{\beta} & \zxX{a} & \zxX{b} & \zxX*{a\pi} & \zxX*{b\pi} & \zxX*{b'\pi} & \zxX*{'b\pi} & \zxZ{(a \oplus b )\pi}
\end{ZX}
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/zx/default style wires}
  Default style for wires. Note that |/zx/wires definition/| is always loaded by default, and we don't add any other style for wires by default. But additional styles may use this functionality.
\end{stylekey}

\begin{stylekey}{/zx/user overlay wires}
  The user can add here additional styles for wires.
\begin{codeexample}[]
\begin{ZX}[/zx/user overlay wires/.style={thick,->,C/.append style={dashed}}]
  \zxNone{} \ar[d,C] \rar[] &[\zxWCol] \zxNone{}\\[\zxWRow]
  \zxNone{} \rar[] & \zxNone{}
\end{ZX}
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/zx/styles/rounded style}
  This is the style loaded by default. It contains internally other (nested) styles that must be defined for any custom style.
\end{stylekey}

We present now all the properties that a new node style must have (and that can overlayed as explained above).
\begin{stylekey}{/zx/styles/rounded style/zxAllNodes}
  Style applied to all nodes.
\end{stylekey}

\begin{stylekey}{/zx/styles/rounded style/zxEmptyDiagram}
  Style to draw an empty diagram.
\end{stylekey}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/styles/rounded style/zxNone\@nil%
  \extractkey/zx/styles/rounded style/zxNone+\@nil%
  \extractkey/zx/styles/rounded style/zxNone-\@nil%
  \extractkey/zx/styles/rounded style/zxNoneI\@nil%
  \makeatother
  \pgfmanualbody
  Styles for None wires (no inner sep, useful to connect to wires). The |-|,|I|,|+| have additional horizontal, vertical, both spaces.
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/styles/rounded style/zxNoneDouble\@nil%
  \extractkey/zx/styles/rounded style/zxNoneDouble+\@nil%
  \extractkey/zx/styles/rounded style/zxNoneDouble-\@nil%
  \extractkey/zx/styles/rounded style/zxNoneDoubleI\@nil%
  \makeatother
  \pgfmanualbody
  Like |zxNone|, but with more space to fake two nodes on a single line (not very used).
\end{pgfmanualentry}

\begin{stylekey}{/zx/styles/rounded style/zxSpiders}
  Style that apply to all circle spiders.
\end{stylekey}

\begin{stylekey}{/zx/styles/rounded style/zxNoPhase}
  Style that apply to spiders without any angle inside. Used by |\zxX{}| when the argument is empty.
\end{stylekey}

\begin{stylekey}{/zx/styles/rounded style/zxNoPhaseSmall}
  Like |zxNoPhase| but for spiders drawn in between wires.
\end{stylekey}

\begin{stylekey}{/zx/styles/rounded style/zxShort}
  Spider with text but no inner space. Used notably to obtain nice fractions.
\end{stylekey}

\begin{stylekey}{/zx/styles/rounded style/zxLong}
  Spider with potentially large text. Used by |\zxX{\alpha}| when the argument is not empty.
\end{stylekey}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/styles/rounded style/zxNoPhaseZ\@nil%
  \extractkey/zx/styles/rounded style/zxNoPhaseX\@nil%
  \extractkey/zx/styles/rounded style/zxNoPhaseSmallZ\@nil%
  \extractkey/zx/styles/rounded style/zxNoPhaseSmallX\@nil%
  \extractkey/zx/styles/rounded style/zxShortZ\@nil%
  \extractkey/zx/styles/rounded style/zxShortX\@nil%
  \extractkey/zx/styles/rounded style/zxLongZ\@nil%
  \extractkey/zx/styles/rounded style/zxLongX\@nil%
  \makeatother
  \pgfmanualbody
  Like above styles, but with colors of |X| and |Z| spider added. The color can be changed globally by updating the |colorZxX| color. By default we use:
  \begin{verse}
    |\definecolor{colorZxZ}{RGB}{204,255,204}|\\
    |\definecolor{colorZxX}{RGB}{255,136,136}|\\
    |\definecolor{colorZxH}{RGB}{255,255,0}|
  \end{verse}
  as the second recommendation in \href{https://zxcalculus.com/accessibility.html}{\texttt{zxcalculus.com/accessibility.html}}.
\end{pgfmanualentry}

\begin{stylekey}{/zx/styles/rounded style/zxH}
  Style for Hadamard spiders, used by |\zxH{}| and uses the color |colorZxH|.
\end{stylekey}

\begin{stylekey}{/zx/styles/rounded style/zxHSmall}
  Like |zxH| but for Hadamard on wires, (see |H| style).
\end{stylekey}

\begin{pgfmanualentry}
  \extractcommand\zxConvertToFracInContent\marg{sign}\marg{num no parens}\marg{denom no parens}\marg{nom parens}\marg{denom parens}\@@
  \extractcommand\zxConvertToFracInLabel\@@
  \pgfmanualbody
  These functions are not meant to be used, but redefined using something like (we use |\zxMinus| as a shorter minus compared to $-$):
\begin{verse}
  |\RenewExpandableDocumentCommand{\zxConvertToFracInLabel}{mmmmm}{%|\\
  |  \ifthenelse{\equal{#1}{-}}{\zxMinus}{#1}\frac{#2}{#3}%|\\
  |}|
\end{verse}
This is used to change how the library does the conversion between |\zxFrac| and the actual written text (either in the node content or in the label depending on the function). The first argument is the sign (string |-| for minus, anything else must be written in place of the minus), the second and third argument are the numerator and denominator of the fraction when used in |\frac{}{}| while the last two arguments are the same except that they include the parens which should be added when using an inline version. For instance, one could get a call |\zxConvertToFracInLabel{-}{a+b}{c+d}{(a+b)}{(c+d)}|. See part on labels to see an example of use.
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \def\extrakeytext{style, }
  \extractcommand\zxMinusUnchanged\@@
  \extractcommand\zxMinus\@@
  \extractcommand\zxMinusInShort\@@
  \makeatletter% should not be letter for \@@... strange
  \extractkey/zx/defaultEnv/zx column sep=length\@nil%
  \extractkey/zx/styles/rounded style preload/small minus\@nil%
  \extractkey/zx/styles/rounded style preload/big minus\@nil%
  \extractkey/zx/styles/rounded style/small minus\@nil%
  \extractkey/zx/styles/rounded style/big minus\@nil%
  \makeatother
  \pgfmanualbody
  |\zxMinus| is the minus sign used in fractions, |\zxMinusInShort| is used in |\zxZ-{\alpha}| and |\zxMinusUnchanged| is a minus sign shorter than $-$. You can redefine them, for instance:
\begin{codeexample}[]
Compare {\def\zxMinusInShort{-}
  \zx{\zxZ-{\alpha}}
} and
{\def\zxMinusInShort{\zxMinus}
  \zx{\zxZ-{\alpha}}
}
\end{codeexample}
You can also choose to always use a big or a small minus, either on a per-node, per-figure, or document-wise.
\begin{codeexample}[]
\begin{ZX}
  \zxFracZ-{\pi}{4} & \zxZ-{\alpha} & \zxZ-{\delta_i} & \zxZ[small minus]-{\delta_i}
\end{ZX} Picture-wise %
\begin{ZX}[small minus]
  \zxZ-{\alpha} & \zxZ-{\delta_i} & \zxZ-{\delta_i} & \zxFracZ-{\pi}{4}
\end{ZX} Document-wise %
\tikzset{/zx/user overlay/.style={small minus}}%
\begin{ZX}
  \zxZ-{\alpha} & \zxZ-{\delta_i} & \zxZ[big minus]-{\delta_i} & \zxFracZ[big minus]-{\pi}{4}
\end{ZX}
\end{codeexample}
\end{pgfmanualentry}

\noindent We also define several spacing commands that can be redefined to your needs:
\begin{pgfmanualentry}
  \extractcommand\zxHCol{}\@@
  \extractcommand\zxHRow{}\@@
  \extractcommand\zxHColFlat{}\@@
  \extractcommand\zxHRowFlat{}\@@
  \extractcommand\zxSCol{}\@@
  \extractcommand\zxSRow{}\@@
  \extractcommand\zxSColFlat{}\@@
  \extractcommand\zxSRowFlat{}\@@
  \extractcommand\zxHSCol{}\@@
  \extractcommand\zxHSRow{}\@@
  \extractcommand\zxHSColFlat{}\@@
  \extractcommand\zxHSRowFlat{}\@@
  \extractcommand\zxWCol{}\@@
  \extractcommand\zxWRow{}\@@
  \extractcommand\zxwCol{}\@@
  \extractcommand\zxwRow{}\@@
  \extractcommand\zxDotsCol{}\@@
  \extractcommand\zxDotsRow{}\@@
  \extractcommand\zxZeroCol{}\@@
  \extractcommand\zxZeroRow{}\@@
  \extractcommand\zxNCol{}\@@
  \extractcommand\zxNRow{}\@@
  \pgfmanualbody
  These are spaces, to use like |&[\zxHCol]| or |\\[\zxHRow]| in order to increase the default spacing of rows and columns depending on the style of the wire. |H| stands for Hadamard, |S| for Spiders, |W| for Wires only, |w| is you link a |zxNone| to a spider (goal is to increase the space), |N| is when you have a |\zxN| and want to reduce the space between columns, |HS| for both Spiders and Hadamard, |Dots| for the 3 dots styles, |Zero| completely resets the default column sep. And of course |Col| for columns, |Row| for rows.
\begin{codeexample}[width=3cm]
\begin{ZX}
 \zxN{} \ar[rd,-N.] &[\zxwCol]    &[\zxwCol] \zxN{} \\[\zxNRow]%%
                    & \zxX{\alpha}
                      \ar[ru,N'-]
                      \ar[rd,N.-] &  \\[\zxNRow]
 \zxN{} \ar[ru,-N']               &  & \zxN{}
\end{ZX}
\end{codeexample}
Note that you can add multiple of them by separating with commas (see |\pgfmatrixnextcell|'s documentation for more details). For instance to have a column separation of exactly |2mm|, do |&[\zxZeroCol,2mm]| (if you just do |&[2mm]| the column will be |2mm| larger). This can also be useful to avoid having a huge space when nodes have multiple empty outputs:
\begin{codeexample}[]
  Compare:
  \begin{ZX}
    \zxN{}      &                              & \zxN{} \\
    \zxN{} \rar & \zxZ{} \ar[ur,<'] \ar[dr,<'] &        \\
                &                              & \zxN{} \\
  \end{ZX}
  with
  \begin{ZX}
    \zxN{}      &                              & \zxN{} \\[\zxZeroRow]
    \zxN{} \rar & \zxZ{} \ar[ur,<'] \ar[dr,<'] &        \\[\zxZeroRow]
                &                              & \zxN{} 
  \end{ZX}
\end{codeexample}
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \def\extrakeytext{style, }
  \extractcommand\zxDefaultColumnSep{}\@@
  \extractcommand\zxDefaultRowSep{}\@@
  \makeatletter% should not be letter for \@@... strange
  \extractkey/zx/defaultEnv/zx column sep=length\@nil%
  \extractkey/zx/defaultEnv/zx row sep=length\@nil%
  \makeatother
  \pgfmanualbody
  |\zxDefaultColumn/RowSep| are the column and row space, and the corresponding styles are to change a single matrix. Prefer to change these parameters compared to changing the |row sep| and |column sep| (without |zx|) of the matrix directly since other spacing styles like |\zxZeroCol| or |\zxNCol| depend on |\zxDefaultColumn|.
\end{pgfmanualentry}


\begin{pgfmanualentry}
  \extractcommand\zxDefaultSoftAngleS{}\@@
  \extractcommand\zxDefaultSoftAngleO{}\@@
  \extractcommand\zxDefaultSoftAngleChevron{}\@@
  \pgfmanualbody
  Default opening angles of |S|, |o| and |v|/|<| wires. Defaults to respectively $30$, $40$ and $45$.
\end{pgfmanualentry}

\subsection{Wire customization}\label{subsec:wirecustom}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/args/-andL/\@nil%
  \extractkey/zx/args/-andL/defaultO (default {-=.2,L=.4})\@nil%
  \extractkey/zx/args/-andL/defaultN (default {-=.2,L=.8})\@nil%
  \extractkey/zx/args/-andL/defaultN- (default {1-=.4,1L=0})\@nil%
  \extractkey/zx/args/-andL/defaultNN (default {})\@nil%
  \extractkey/zx/args/-andL/defaultNIN (default {1-=0,1L=.6})\@nil%
  \extractkey/zx/args/-andL/defaultS (default {-=.8,L=0})\@nil%
  \extractkey/zx/args/-andL/defaultS' (default {-=.8,L=.2})\@nil%
  \extractkey/zx/args/-andL/default-S (default {1-=.8,1L=0})\@nil%
  \extractkey/zx/args/-andL/defaultSIS (default {1-=0,1L=.8})\@nil%
  \makeatother
  \pgfmanualbody
  Default values used by wires (). You can customize them globally using something like:
  \begin{verse}
    |\tikzset{|\\
    |  /zx/args/-andL/.cd,|\\
    |  defaultO/.style={-=.2,L=.4}|\\
    |}|
   \end{verse}
   Basically |defaultO| will configure all the |o| familly, |defaultS'| will configure all the ``soft'' versions of |s|, |default-S| will configure the anchor on the side of the vertical arrival\dots{} For more details or which wire uses which configuration, check the default value given in each style definition.
\end{pgfmanualentry}

\subsection{Wires starting inside or on the boundary of the node}\label{subsec:wiresInsideOutside}

This library provides multiple methods to draw the wires between the nodes (for all curves depending on |bezier|, which is basically everything but |C| and straight lines).

\paragraph{Default drawing method.}
By default the lines will be drawn behind the node and the starting and ending points will be defined to be a |fake center *| anchor (if it exists, the exact chosen anchors (north, south\dots{}) depending on the direction). Because this anchor lies behind the node, we put them on the |edgelayer| layer. For debugging purpose, it can be practical to display them:
\begin{pgfmanualentry}
  \def\extrakeytext{style, }
  \extractcommand\zxEdgesAbove\@@
  \makeatletter% should not be letter for \@@... strange
  \extractkey/zx/wires definition/edge above\@nil%
  \extractkey/zx/wires definition/edge not above\@nil%
  \makeatother
  \pgfmanualbody
  If the macro |\zxEdgesAbove| is undefined (using |\let\zxEdgesAbove\undefined|) edges will be drawn above the nodes. To change it on a per-edge basis, use |edge above| (or its contrary |edge not above|) \emph{before the name of the wire}. This is mostly useful to understand how lines are drawn and for debugging purpose.
\begin{codeexample}[]
  What you see:
  \zx{\zxZ{\alpha+\beta} \ar[dr,s] \\
                         & \zxZ{\alpha+\beta}}
  What is drawn:
  \zx{\zxZ{\alpha+\beta} \ar[dr,edge above,s] \\
                         & \zxZ{\alpha+\beta}}
\end{codeexample}
(you can note the fact that the wire does not start at the center but at a |fake center *| anchor to provide a nicer look)
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \def\extrakeytext{style, }
  \extractcommand\zxControlPointsVisible\@@
  \makeatletter% should not be letter for \@@... strange
  \extractkey/zx/wires definition/control points visible\@nil%
  \extractkey/zx/wires definition/control points not visible\@nil%
  \makeatother
  \pgfmanualbody
  Similarly, it can be useful for debugging to see the control points of the curves (note that |C|, straight lines and |(| wires are not based on our curve system, so it won't do anything for them). If the macro |\zxControlPointsVisible| is defined (using |\def\zxEdgesAbove{}|) control points will be drawn. To change it on a per-edge basis, use |control points visible| (or its contrary |control points not visible|). This is mostly useful to understand how lines are drawn and for debugging purpose.
\begin{codeexample}[]
  Controls not visible:
  \zx{\zxZ{\alpha+\beta} \ar[dr,s] \\
                         & \zxZ{\alpha+\beta}}
  Control visible:
  \zx{\zxZ{\alpha+\beta} \ar[dr,control points visible,s] \\
                         & \zxZ{\alpha+\beta}}
  Control visible + edge above:
  \zx{\zxZ{\alpha+\beta} \ar[dr,edge above,control points visible,s] \\
                         & \zxZ{\alpha+\beta}}
\end{codeexample}
\textbf{WARNING}: this command adds some points in the wire path, and in particular if you have a |H| wire (Hadamard in the middle of the wire), this option will not place it correctly. But it's not really a problem since it's just to do a quick debugging.
\end{pgfmanualentry}

Unfortunately, the default drawing method also has drawbacks. For instance, when using the |H| edge between a spider and an empty node, the ``middle'' of the edge will appear too close to the center by default (we draw the first edge above to illustrate the reason of this visual artifact):
\begin{codeexample}[width=0cm]
\begin{ZX}
 \zxN{} \ar[rd,edge above,-N.,H] &[\zxwCol,\zxHCol]  &[\zxwCol,\zxHCol] \zxN{} \\[\zxNRow]%%
                                 & \zxX{\alpha}
                                   \ar[ru,N'-,H]
                                   \ar[rd,N.-,H] &  \\[\zxNRow]
 \zxN{} \ar[ru,-N',H]                        &  & \zxN{}
\end{ZX}
\end{codeexample}
To solve that issue, you need to manually position the |H| node as shown before:
\begin{codeexample}[width=0cm]
\begin{ZX}
 \zxN{} \ar[rd,edge above,-N.,H={pos=.35}] &[\zxwCol,\zxHCol]  &[\zxwCol,\zxHCol] \zxN{} \\[\zxNRow]%%
                                           & \zxX{\alpha}
                                             \ar[ru,N'-,H={pos=1-.35}]
                                             \ar[rd,N.-,H={pos=1-.35}] &  \\[\zxNRow]
 \zxN{} \ar[ru,-N',H={pos=.35}]                                  &  & \zxN{}
\end{ZX}
\end{codeexample}
Or manually position the anchor outside the node (you can use angles, centered on the real center on the shape), but be aware that it can change the shape of the node (see below):
\begin{codeexample}[width=0cm]
\begin{ZX}
 \zxN{} \ar[rd,edge above,-N.,H,end anchor=180-45] &[\zxwCol,\zxHCol]  &[\zxwCol,\zxHCol] \zxN{} \\[\zxNRow]%%
                                           & \zxX{\alpha}
                                             \ar[ru,N'-,H,start anchor=45]
                                             \ar[rd,N.-,H,start anchor=-45] &  \\[\zxNRow]
 \zxN{} \ar[ru,-N',H,end anchor=180+45]                                  &  & \zxN{}
\end{ZX}
\end{codeexample}

A second drawback is that it is not possible to add arrows on the curved wires (except |C| which uses a different approach), since they will be hidden behind the node:
\begin{codeexample}[]
  What you see:
  \zx{\zxZ{\alpha+\beta} \ar[dr,s,<->] \\
                         & \zxZ{\alpha+\beta}}
  What is drawn:
  \zx{\zxZ{\alpha+\beta} \ar[dr,edge above,s,<->] \\
                         & \zxZ{\alpha+\beta}}
\end{codeexample}
Here, the only solution (without changing the drawing mode) is to manually position the anchor as before\dots{} but note that on nodes with a large content |45| degrees is actually nearly on the top since the angle is not taken from a fake center but from the real center of the node.
\begin{codeexample}[]
  \zx{\zxZ{\alpha+\beta} \ar[dr,s,<->,start anchor=-45,end anchor=180-45] \\
                         & \zxZ{\alpha+\beta}}
  \zx{\zxZ{\alpha+\beta} \ar[dr,s,<->,start anchor=-15,end anchor=180-15] \\
                         & \zxZ{\alpha+\beta}}
\end{codeexample}
 Note that the shape of the wire may be a bit different since the ending and leaving parts was hidden before, and the current styles are not designed to look nicely when starting on the border of a node. For that reason, you may need to tweak the style of the wire yourself using |-|, |L| options.

 \paragraph{The ``intersection'' drawing methods}

 We also define other modes to draw wires (they are very new and not yet tested a lot). In the first mode, appropriate |fake center *| is taken, then depending on the bezier control points, a point is taken on the border of the shape (starting from the fake center and using the direction of the bezier control point). Then the node is drawn. Here is how to enable this mode:

\begin{pgfmanualentry}
  \def\extrakeytext{style, }
  \extractcommand\zxEnableIntersections\marg{}\@@
  \extractcommand\zxDisableIntersections\marg{}\@@
  \extractcommand\zxEnableIntersectionsNodes\@@
  \extractcommand\zxEnableIntersectionsWires\@@
  \makeatletter% should not be letter for \@@... strange
  \extractkey/zx/wires definition/use intersections\@nil%
  \extractkey/zx/wires definition/dont use intersections\@nil%
  \makeatother
  \pgfmanualbody
  The simpler method to enables or disable intersections is to call |\zxEnableIntersections{}| or |\zxDisableIntersections{}| (potentially in a group to have a local action only). Note that \emph{this does not automatically adapt the styles}, see |ui| to adapt the styles automatically.
\begin{codeexample}[width=0cm]
{% Enable intersections (but does not load our custom "intersections" style, see ui).
  \zxEnableIntersections{}% Small space left = artifact of the documentation
  \begin{ZX}
    \zxN{} \ar[rd,edge above,-N.,H] &[\zxwCol,\zxHCol] &[\zxwCol,\zxHCol] \zxN{} \\[\zxNRow]%%
                                    & \zxX{\alpha}
                                      \ar[ru,N'-,H]
                                      \ar[rd,N.-,H]    &  \\[\zxNRow]
    \zxN{} \ar[ru,-N',H]            &                  & \zxN{}
  \end{ZX}
}
\end{codeexample}
(The |edge above| is just to show that the wire does not go inside.) However, this method enable intersections for the whole drawing. You can disable it for a single arrow using the |dont use intersections| style. But it is possible instead to enable it for a single wire. To do that, first define |\def\zxEnableIntersectionsNodes{}| (it will automatically add a |name path| on each node. If you don't care about optimizations, you can just define it once at the beginning of your project), and then use |use intersections| on the wires which should use intersections:
\begin{codeexample}[width=0cm]
{% Create the machinary needed to compute intersections, but does not enable it.
  \def\zxEnableIntersectionsNodes{}% Small space left = artifact of the documentation
  \begin{ZX}
    \zxN{} \ar[rd,edge above,-N.,H, %% "use intersections" does not load any style, cf ui.
            use intersections] &[\zxwCol,\zxHCol]  &[\zxwCol,\zxHCol] \zxN{} \\[\zxNRow]%%
                                                   & \zxX{\alpha}
                                                     \ar[ru,edge above,N'-,H,use intersections]
                                                        \ar[rd,edge above,N.-,H]  &  \\[\zxNRow]
    \zxN{} \ar[ru,edge above,-N',H]                &                              & \zxN{}
  \end{ZX}
}
\end{codeexample}
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \def\extrakeytext{style, }
  \makeatletter% should not be letter for \@@... strange
  \extractkey/zx/wires definition/ui\@nil%
  \makeatother
  \pgfmanualbody
  This method has however a few drawbacks. One of the first reason that explains why we don't use it by default is that it is quite long to compute (it involves the |intersections| library to obtain the bezier point to start at and my code may also be not very well optimized as I'm a beginner with \LaTeX{} and \tikzname{} programming\dots{} and what a strange language!). Secondly, it has not yet been tested a lot. Note also that the default wire styles have not been optimized for this setup and the results may vary compared to the default drawing mode (sometimes they are ``better'', sometimes they are not). We have however tried to define a second style |/zx/args/-andL/ui/| that have nicer results. To load it, just type |ui| \emph{before the wire style name}, it will automatically load |use intersections| together with our custom styles (see below how to use |user overlay wires| to load it by default):
%%% I'm not sure why, but inside codeexample if I write zxEnableIntersections{}%<go to line>\begin{ZX}... then an additional space is added... Not sure why.
\begin{codeexample}[]
{%
  \def\zxEnableIntersectionsNodes{}
  Before \begin{ZX}
    \zxX{\beta} \ar[r,o'] & \zxX{}
  \end{ZX} after \begin{ZX}
    \zxX{\beta} \ar[r,o',use intersections] & \zxX{}
  \end{ZX} corrected manually \begin{ZX}
    \zxX{\beta} \ar[r,edge above, use intersections, o'={-=.2,L=.15}] & \zxX{}
  \end{ZX} or with our custom style \begin{ZX}
    \zxX{\beta} \ar[r,edge above, ui, o'] & \zxX{}
  \end{ZX}.
}
\end{codeexample}
Here are further comparisons:
\begin{codeexample}[]
{%
  \def\zxEnableIntersectionsNodes{}
  Before \begin{ZX}
    \zxX{} \ar[r,o'] & \zxX{}
  \end{ZX} ui \begin{ZX}
    \zxX{} \ar[r, ui, o'] & \zxX{}
  \end{ZX}. Before \begin{ZX}
    \zxX{\alpha} \ar[r,o'] & \zxZ{\beta}
  \end{ZX} ui \begin{ZX}
    \zxX{\alpha} \ar[r, ui, o'] & \zxZ{\beta}
  \end{ZX}. Before \begin{ZX}
    \zxX{\alpha+\beta} \ar[r,o'] & \zxZ{\alpha+\beta}
  \end{ZX} ui \begin{ZX}
    \zxX{\alpha+\beta} \ar[r, ui, o'] & \zxZ{\alpha+\beta}
  \end{ZX}.
}
\end{codeexample}
With |N|:
\begin{codeexample}[]
{%
  \def\zxEnableIntersectionsNodes{}
  \begin{ZX}
    \zxX{} \ar[rd,N]\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{} \ar[rd,ui,N]\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,N]\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,N]\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,N]\\ & \zxX{\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,N]\\ & \zxX{\beta}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,N]\\ & \zxX{\alpha+\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,ui,N]\\ & \zxX{\alpha+\beta}
  \end{ZX}.
}
\end{codeexample}

With |N-|:
\begin{codeexample}[]
{%
  \def\zxEnableIntersectionsNodes{}
  \begin{ZX}
    \zxX{} \ar[rd,N-]\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{} \ar[rd,ui,N-]\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,N-]\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,N-]\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,N-]\\ & \zxX{\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,N-]\\ & \zxX{\beta}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,N-]\\ & \zxX{\alpha+\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,ui,N-]\\ & \zxX{\alpha+\beta}
  \end{ZX}.
}
\end{codeexample}

With |<.|:
\begin{codeexample}[]
{%
  \def\zxEnableIntersectionsNodes{}
  \begin{ZX}
    \zxX{} \ar[rd,<.]\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{} \ar[rd,ui,<.]\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,<.]\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,<.]\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,<.]\\ & \zxX{\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,<.]\\ & \zxX{\beta}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,<.]\\ & \zxX{\alpha+\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,ui,<.]\\ & \zxX{\alpha+\beta}
  \end{ZX}.
}
\end{codeexample}

With |NIN|:
\begin{codeexample}[]
{%
  \def\zxEnableIntersectionsNodes{}
  \begin{ZX}
    \zxX{} \ar[rd,NIN]\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{} \ar[rd,ui,NIN]\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,NIN]\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,NIN]\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,NIN]\\ & \zxX{\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,NIN]\\ & \zxX{\beta}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,NIN]\\ & \zxX{\alpha+\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,ui,NIN]\\ & \zxX{\alpha+\beta}
  \end{ZX}.
}
\end{codeexample}

With this mode |s| behaves basically like |S| since the only difference is the anchor:
\begin{codeexample}[]
{%
  \def\zxEnableIntersectionsNodes{}
  \begin{ZX}
    \zxX{} \ar[rd,s]\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{} \ar[rd,ui,s]\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,s]\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,s]\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,s]\\ & \zxX{\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,s]\\ & \zxX{\beta}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,s]\\ & \zxX{\alpha+\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,ui,s]\\ & \zxX{\alpha+\beta}
  \end{ZX}.
}
\end{codeexample}

With |s'|:
\begin{codeexample}[]
{%
  \def\zxEnableIntersectionsNodes{}
  \begin{ZX}
    \zxX{} \ar[rd,s']\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{} \ar[rd,ui,s']\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,s']\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,s']\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,s']\\ & \zxX{\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,s']\\ & \zxX{\beta}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,s']\\ & \zxX{\alpha+\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,ui,s']\\ & \zxX{\alpha+\beta}
  \end{ZX}.
}
\end{codeexample}

With |-s|:
\begin{codeexample}[]
{%
  \def\zxEnableIntersectionsNodes{}
  \begin{ZX}
    \zxX{} \ar[rd,-s]\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{} \ar[rd,ui,-s]\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,-s]\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,-s]\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,-s]\\ & \zxX{\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,-s]\\ & \zxX{\beta}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,-s]\\ & \zxX{\alpha+\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,ui,-s]\\ & \zxX{\alpha+\beta}
  \end{ZX}.
}
\end{codeexample}

With |SIS|:
\begin{codeexample}[]
{%
  \def\zxEnableIntersectionsNodes{}
  \begin{ZX}
    \zxX{} \ar[rd,SIS]\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{} \ar[rd,ui,SIS]\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,SIS]\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,SIS]\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,SIS]\\ & \zxX{\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,SIS]\\ & \zxX{\beta}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,SIS]\\ & \zxX{\alpha+\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,ui,SIS]\\ & \zxX{\alpha+\beta}
  \end{ZX}.
}
\end{codeexample}

With |^.|:
\begin{codeexample}[]
{%
  \def\zxEnableIntersectionsNodes{}
  \begin{ZX}
    \zxX{} \ar[rd,^.]\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{} \ar[rd,ui,^.]\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,^.]\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,^.]\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,^.]\\ & \zxX{\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,^.]\\ & \zxX{\beta}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,^.]\\ & \zxX{\alpha+\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,ui,^.]\\ & \zxX{\alpha+\beta}
  \end{ZX}.
}
\end{codeexample}

Now using our favorite drawing. Here we illustrate how we apply our custom style to all arrows.
\begin{codeexample}[width=0pt]
\def\zxEnableIntersectionsNodes{}%
\tikzset{
  /zx/user overlay wires/.style={
    ui, % Other method
  }
}
\begin{ZX}[
  execute at begin picture={%
    %%% Definition of long items (the goal is to have a small and readable matrix
    % (warning: macro can't have numbers in TeX. Also, make sure not to use existing names)
    \def\Zpifour{\zxFracZ[a=Zpi4]-{\pi}{4}}%
    \def\mypitwo{\zxFracX[a=mypi2]{\pi}{2}}%
  }
  ]
  %%% Matrix: in emacs "M-x align" is practical to automatically format it. a is for 'alias'
  & \zxN[a=n]{}  & \zxZ[a=xmiddle]{}       &            & \zxN[a=out1]{} \\
  \zxN[a=in1]{} & \Zpifour{}   & \zxX[a=Xdown]{}         & \mypitwo{} &                \\
  &              &                         &            & \zxN[a=out2]{} \\
  \zxN[a=in2]{} & \zxX[a=X1]{} & \zxZ[a=toprightpi]{\pi} &            & \zxN[a=out3]{}
  %%% Arrows
  % Column 1
  \ar[from=in1,to=X1,s]
  \ar[from=in2,to=Zpi4,.>]
  % Column 2
  \ar[from=X1,to=xmiddle,N']
  \ar[from=X1,to=toprightpi,H]
  \ar[from=Zpi4,to=n,C] \ar[from=n,to=xmiddle,wc]
  \ar[from=Zpi4,to=Xdown]
  % Column 3
  \ar[from=xmiddle,to=Xdown,C-]
  \ar[from=xmiddle,to=mypi2,'>]
  % Column 4
  \ar[from=toprightpi,to=mypi2,-N]
  \ar[from=mypi2,to=out1,<']
  \ar[from=mypi2,to=out2,<.]
  \ar[edge above,use intersections,from=Xdown,to=out3,<.]
\end{ZX}
\end{codeexample}

The same using |control points visible| to check if the good styles are applied:
\begin{codeexample}[width=0pt]
\def\zxEnableIntersectionsNodes{}%
\tikzset{
  /zx/user overlay wires/.style={
    ui, % Enable our style on all
    edge above, % For debugging
    control points visible % For debugging
  }
}
\def\zxDebugMode{}
\def\zxControlPointsVisible{}
\begin{ZX}[
  execute at begin picture={%
    %%% Definition of long items (the goal is to have a small and readable matrix
    % (warning: macro can't have numbers in TeX. Also, make sure not to use existing names)
    \def\Zpifour{\zxFracZ[a=Zpi4]-{\pi}{4}}%
    \def\mypitwo{\zxFracX[a=mypi2]{\pi}{2}}%
  }
  ]
  %%% Matrix: in emacs "M-x align" is practical to automatically format it. a is for 'alias'
  & \zxN[a=n]{}  & \zxZ[a=xmiddle]{}       &            & \zxN[a=out1]{} \\
  \zxN[a=in1]{} & \Zpifour{}   & \zxX[a=Xdown]{}         & \mypitwo{} &                \\
  &              &                         &            & \zxN[a=out2]{} \\
  \zxN[a=in2]{} & \zxX[a=X1]{} & \zxZ[a=toprightpi]{\pi} &            & \zxN[a=out3]{}
  %%% Arrows
  % Column 1
  \ar[from=in1,to=X1,s]
  \ar[from=in2,to=Zpi4,.>]
  % Column 2
  \ar[from=X1,to=xmiddle,N']
  \ar[from=X1,to=toprightpi,H]
  \ar[from=Zpi4,to=n,C] \ar[from=n,to=xmiddle,wc]
  \ar[from=Zpi4,to=Xdown]
  % Column 3
  \ar[from=xmiddle,to=Xdown,C-]
  \ar[from=xmiddle,to=mypi2,'>]
  % Column 4
  \ar[from=toprightpi,to=mypi2,-N]
  \ar[from=mypi2,to=out1,<']
  \ar[from=mypi2,to=out2,<.]
  \ar[edge above,use intersections,from=Xdown,to=out3,<.]
\end{ZX}
\end{codeexample}

Now, we can also globally enable the |ui| style and the intersection only for some kinds of arrows. For instance (here we enable it for all styles based on |N|, i.e.\ |*N*| and |>|-like wires). See that the |s| node is note using the intersections mode:
\begin{codeexample}[width=0pt]
\def\zxEnableIntersectionsNodes{}%
\tikzset{
  /zx/user overlay wires/.style={
    %% Nbase changes both N-like and >-like styles.
    %% Use N/.append to change only N-like.
    Nbase/.append style={%
      ui, % intersection only for arrows based on N (N and <)
    },
    edge above, % For debugging
    control points visible % For debugging
  }
}
\def\zxDebugMode{}
\def\zxControlPointsVisible{}
\begin{ZX}[
  execute at begin picture={%
    %%% Definition of long items (the goal is to have a small and readable matrix
    % (warning: macro can't have numbers in TeX. Also, make sure not to use existing names)
    \def\Zpifour{\zxFracZ[a=Zpi4]-{\pi}{4}}%
    \def\mypitwo{\zxFracX[a=mypi2]{\pi}{2}}%
  }
  ]
  %%% Matrix: in emacs "M-x align" is practical to automatically format it. a is for 'alias'
  & \zxN[a=n]{}  & \zxZ[a=xmiddle]{}       &            & \zxN[a=out1]{} \\
  \zxN[a=in1]{} & \Zpifour{}   & \zxX[a=Xdown]{}         & \mypitwo{} &                \\
  &              &                         &            & \zxN[a=out2]{} \\
  \zxN[a=in2]{} & \zxX[a=X1]{} & \zxZ[a=toprightpi]{\pi} &            & \zxN[a=out3]{}
  %%% Arrows
  % Column 1
  \ar[from=in1,to=X1,s]
  \ar[from=in2,to=Zpi4,.>]
  % Column 2
  \ar[from=X1,to=xmiddle,N']
  \ar[from=X1,to=toprightpi,H]
  \ar[from=Zpi4,to=n,C] \ar[from=n,to=xmiddle,wc]
  \ar[from=Zpi4,to=Xdown]
  % Column 3
  \ar[from=xmiddle,to=Xdown,C-]
  \ar[from=xmiddle,to=mypi2,'>]
  % Column 4
  \ar[from=toprightpi,to=mypi2,-N]
  \ar[from=mypi2,to=out1,<']
  \ar[from=mypi2,to=out2,<.]
  \ar[edge above,use intersections,from=Xdown,to=out3,<.]
\end{ZX}
\end{codeexample}

\end{pgfmanualentry}

\begin{pgfmanualentry}
  \def\extrakeytext{style, }
  \extractcommand\zxIntersectionLineBetweenStartEnd\@@
  \makeatletter% should not be letter for \@@... strange
  \extractkey/zx/wires definition/intersections mode between start end\@nil%
  \extractkey/zx/wires definition/intersections mode bezier controls\@nil%
  \makeatother
  \pgfmanualbody

Node that we also defined another intersection mechanism, in which the intersection with the node boundary is computed using the line that links the two fake centers of the starting and ending point. To use it, either define |\def\zxIntersectionLineBetweenStartEnd{}| or use the style |intersections between start end| (or to come back to the normal intersection mode |intersections bezier controls|). Note that this just changes the mode of computing intersections, but does not enable intersections, you still need to enable intersections as explained above (for instance using |use intersection|, or |ui| if you also want to load our style). Note however that we don't spent too much effort in this mode as the result is often not really appealing, in particular the |o| shapes, and therefore we designed no special style for it and made only a few tests.
\begin{codeexample}[]
{%
  \def\zxEnableIntersectionsNodes{}
  \begin{ZX}
    \zxX{\alpha} \ar[rd,N]\\ & \zxX{\beta}
  \end{ZX} $\Rightarrow $ between start end \begin{ZX}
    \zxX{\alpha} \ar[edge above,rd,ui,intersections mode between start end,N]\\ & \zxX{\beta}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[r,o'] \ar[r,o.] & \zxX{\beta}
  \end{ZX} $\Rightarrow $ between start end \begin{ZX}
    \zxX{\alpha} \ar[r,ui,intersections mode between start end,o']
                 \ar[r,ui,intersections mode between start end,o.] & \zxX{\beta}
  \end{ZX}.
}
\end{codeexample}
\end{pgfmanualentry}

\subsection{Nested diagrams}


If you consider this example:

\begin{codeexample}[]
Alone \begin{ZX}
  \zxX{} \rar \ar[r,o'] \ar[r,o.] & \zxZ{}
\end{ZX} %
in a diagram %
\begin{ZX}[math baseline=myb]
                     &[\zxwCol] \zxFracX-{\pi}{2} & \zxX{}
                                                    \rar
                                                    \ar[r,o']
                                                    \ar[r,o.] & \zxZ{} &[\zxwCol]\\
  \zxN[a=myb]{} \rar & \zxFracZ{\pi}{2} \rar & \zxFracX{\pi}{2} \rar & \zxFracZ{\pi}{2} \rar & \zxN{}
\end{ZX}
\end{codeexample}

You can see that the constant looks much wider in the second picture, due to the fact that the nodes below increase the column size. One solution I found for this problem is to use |savebox| to create your drawing \emph{before} the diagram, and then use the |fit| library to include it where you want in the matrix (see below for a command that does that automatically):

\begin{codeexample}[width=0pt]
%% Create a new box
\newsavebox{\myZXbox}
%% Save our small diagram.
%% Warning: on older versions, you needed to use \& instead of &
%% (the char '&' cause troubles in functions), but I fixed it 2022/02/09
\sbox{\myZXbox}{%
  % add \tikzset{external/optimize=false} if you use tikz "external" library %
  \zx{ % you may need 
    \zxX{} \rar \ar[r,o'] \ar[r,o.] & \zxZ{}
  }%
}

$x = \begin{ZX}[
  execute at end picture={
    %% Add our initial drawing at the end:
    \node[fit=(start)(end),yshift=-axis_height] {\usebox{\myZXbox}};
  },
  math baseline=myb]
                     &[\zxwCol] \zxFracX-{\pi}{2} & \zxN[a=start]{}       & \zxN[a=end]\\
  \zxN[a=myb]{} \rar & \zxFracZ{\pi}{2} \rar      & \zxFracX{\pi}{2} \rar & \zxFracZ{\pi}{2} \rar & \zxN{}
\end{ZX}$
\end{codeexample}

Note that this has the advantage of preserving the baseline of the big drawing. However, it is a bit cumbersome to use, so we provide here a wrapper that automatically does the following code (this has not been tested extensively, and may be subject to changes):

\begin{pgfmanualentry}
  \def\extrakeytext{style, }
  \extractcommand\zxSaveDiagram\marg{name with backslash}\opt{\oarg{zx options}}\marg{diagram with ampersand \textbackslash\&}\@@
  \makeatletter% should not be letter for \@@... strange
  \extractkey/zx/wires definition/use diagram=\marg{name with \textbackslash}\marg{(nodes)(to)(fit)}\@nil%
  \makeatother
  \pgfmanualbody
  Use |\zxSaveDiagram| to save and name a diagram (must be done before the diagram you want to insert this diagram into, also \textbf{do not forget the backslash before the name} (note that before 2022/09/02, you needed to use |\&| instead of |&|, but this has been fixed after 2022/02/09. In case you really care about backward compatibility, either download the sty file in your folder, or add |ampersand replacement=\&| in the options of the |\zxSaveDiagram| function and use |\&| as before). Then, |use diagram| to insert it inside a diagram (the second argument is a list of nodes given to the |fit| library):
\begin{codeexample}[width=0pt]
%%             v---- note the backslash
\zxSaveDiagram{\myZXconstant}{\zxX{} \rar \ar[r,o'] \ar[r,o.] & \zxZ{}}
$x = \begin{ZX}[use diagram={\myZXconstant}{(start)(end)}, math baseline=myb]
                     &[\zxwCol] \zxFracX-{\pi}{2} & \zxN[a=start]{}       & \zxN[a=end]\\
  \zxN[a=myb]{} \rar & \zxFracZ{\pi}{2} \rar      & \zxFracX{\pi}{2} \rar & \zxFracZ{\pi}{2} \rar & \zxN{}
\end{ZX}$
\end{codeexample}
Note that if you need more space to insert the drawing, you can use |\zxN+[a=start,minimum width=2cm]{}| instead of |\zxN|.
\end{pgfmanualentry}

Sometimes, you may also find useful to stack diagram (for instance because the matrix of the first diagram is not related to the matrix of the second diagram), or position multiple diagrams relative to each others. You can use arrays to do that, but it will not preserve the baseline. Another solution is to put the |ZX| environment inside nodes contained in |tikzpicture| (I know that tikz does not like nesting\dots{} but it works nice for what I tried. I will also try to provide an helper function to do that later). For example here we use it to add the constants below the second diagram:
\begin{codeexample}[vbox]
\begin{equation*}
  \begin{ZX}
    &[\zxwCol]       &                                      &[\zxwCol] \zxN{} \ar[dd,3 vdots] \\[\zxNCol]
    \zxN{} \rar & \zxZ{\pi} \rar & \zxX{\alpha} \ar[ru,N'-] \ar[rd,N.-] &                        \\[\zxNCol]
    &                &                                      & \zxN{}
  \end{ZX} =
  \begin{tikzpicture}[
    baseline=(A.base)
    ]
    \node[inner sep=0pt](A){%
      \begin{ZX}
        &[\zxwCol]                              & \zxZ{\pi} \ar[dd,3 vdots] \rar &[\zxwCol] \zxN{} \\[\zxNCol]
        \zxN{} \rar & \zxX-{\alpha} \ar[ru,N'-] \ar[rd,N.-] &                                        \\[\zxNCol]
        &                                       & \zxZ{\pi} \rar & \zxN{}
      \end{ZX}
    };
    \node[inner sep=0pt,below=\zxDefaultColumnSep of A](B){
      \begin{ZX}
        \zxOneOverSqrtTwo{} & \zxX{\alpha} \rar & \zxZ{\pi}
      \end{ZX}
    };
  \end{tikzpicture}
\end{equation*}
\end{codeexample}

\subsection{Further customization}

You can further customize your drawings using any functionality from \tikzname{} and |tikz-cd| (but it is of course at your own risk). For instance, we can change the separation between rows and/or columns for a whole picture (but prefer to use |zx row sep| as it also updates pre-configured column spaces):
\begin{codeexample}[width=0pt]
  \begin{ZX}[row sep=1mm]
                &                                         &                        & & \zxZ{\pi} \\
    \zxN{} \rar & \zxX{} \ar[rd,(.] \ar[urrr,(',H]        &                        & &  & \zxN{} \\
                &                                         & \zxZ{} \ar[rd,s.] \rar &
       \zxFracX{\pi}{2} \ar[uur,('] \ar[rru,<'] \ar[rr] &  & \zxN{} \\
    \zxN{} \rar & \zxFracZ-{\pi}{4} \ar[ru,('] \ar[rr,o.] &            & \zxX{} \ar[rr] &  & \zxN{}
  \end{ZX}
\end{codeexample}
Or we can define our own style to create blocks:
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
{ % \usetikzlibrary{shadows}
  \tikzset{
    my bloc/.style={
      anchor=center,
      inner sep=2pt,
      inner xsep=.7em,
      minimum height=3em,
      draw,
      thick,
      fill=blue!10!white,
      double copy shadow={opacity=.5},tape,
    }
  }
  \zx{|[my bloc]| f \rar &[1mm] |[my bloc]| g \rar &[1mm] \zxZ{\alpha} \rar & \zxNone{}}
}
\end{codeexample}
}
We can also use for instance |fit|, |alias|, |execute at end picture| and layers (the user can use |background| for things behind the drawing, |box| for special nodes above the drawings (like multi-column nodes, see below), and |foreground| which is even higher) to do something like that:
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=3cm]
% \usetikzlibrary{fit}
\begin{ZX}[
  execute at end picture={
    \node[
      inner sep=2pt,
      node on layer=background, %% Ensure the node is behind the drawing
      rounded corners,
      draw=blue,
      dashed,
      fill=blue!50!white,
      opacity=.5,
      fit=(cnot1)(cnot2), %% position of the node, thanks fit library
      "\textsc{cnot}" {above, inner sep=1mm} %% Adds label, thanks quote library. Not sure why, inner sep is set to 0 when using tikz "external" library.
    ] {};
  }
  ]
  \zxNone{} \rar & \zxZ[alias=cnot1]{} \dar \rar & \zxNone{}\\
  \zxNone{} \rar & \zxX[alias=cnot2]{} \rar      & \zxNone{}\\
\end{ZX}
\end{codeexample}
Because this code is quite lengthy and useful, we provide in \cref{subsec:decoration} a shorter syntax.
}

\section{Future works}

There is surely many things to improve in this library, and given how young it is there is surely many undiscovered bugs. So feel free to propose ideas or report bugs \mylink{https://github.com/leo-colisson/zx-calculus/issues}{one the github page}. The intersections code is also quite slow, so I would be curious to check if I can optimize it (the first goal was to make it work). I should also work on the compatibility with tikzit (basically just write tikz configuration files that you can just use and document how to use tikzit with it), or even write a dedicated graphical tool (why not based on tikzit itself, or \mylink{https://tikzcd.yichuanshen.de/}{this tool}). I also want to find a nicer way to merge cells (for now I propose to use the |fit| library but it's not very robust against overlays) and to nest ZX diagrams. And of course fix typos in the documentation and write other styles, including notations not specific to ZX-calculus. Feel free to submit Pull Requests to solve that, or to submit bug reports to explain uncovered use-cases!

\section{Acknowledgement}

I'm very grateful of course to everybody that worked on these amazing field which made diagramatic quantum computing possible, and to the many StackExchange users that helped me to understand a bit more \LaTeX{} and \tikzname{} (sorry, I don't want to risk an incomplete list, but many thanks to egreg, David Carlisle, cfr, percusse, Andrew Stacey, Henri Menke, SebGlav, Qrrbrbirlbel\dots{}). I also thank Robert Booth for making me realize how my old style was ugly, and for giving advices on how to improve it. Thanks to John van de Wetering, whose style has also been a source of inspiration~\cite{van20_ZXcalculusWorkingQuantum}.

\section{Changelog}

\begin{itemize}
\item 2022/02/09:
  \begin{itemize}
  \item Added compatibility with external tikz library
  \item More robust handling of |&|: align and macros does not need |\&| anymore.
  \item |\&| in |\zxSaveDiagram| is replaced with |&|. This introduces a small backward incompatibility, but hey, I said it was still subject to changes :-)
  \end{itemize}
\end{itemize}

\printindex

\printbibliography[heading=bibintoc]

\end{document}
